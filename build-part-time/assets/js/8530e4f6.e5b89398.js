"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[83045],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var s=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},o=Object.keys(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var r=s.createContext({}),h=function(e){var t=s.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=h(e.components);return s.createElement(r.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=h(n),u=a,m=p["".concat(r,".").concat(u)]||p[u]||d[u]||o;return n?s.createElement(m,l(l({ref:t},c),{},{components:n})):s.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,l=new Array(o);l[0]=u;var i={};for(var r in t)hasOwnProperty.call(t,r)&&(i[r]=t[r]);i.originalType=e,i[p]="string"==typeof e?e:a,l[1]=i;for(var h=2;h<o;h++)l[h]=n[h];return s.createElement.apply(null,l)}return s.createElement.apply(null,n)}u.displayName="MDXCreateElement"},57302:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});var s=n(7896),a=(n(2784),n(30876));const o={title:"Optional: Accessing Stylesheets in the CSSOM",id:"optional-accessing-stylesheets-in-the-cssom",slug:"optional-accessing-stylesheets-in-the-cssom",hide_table_of_contents:!0,sidebar_position:2,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/javascript-full-stack/blob/main/2c_accessing_style_sheets_with_CSSOM.md"},l=void 0,i={unversionedId:"intermediate-javascript/object-oriented-javascript-part-2/optional-accessing-stylesheets-in-the-cssom",id:"intermediate-javascript/object-oriented-javascript-part-2/optional-accessing-stylesheets-in-the-cssom",title:"Optional: Accessing Stylesheets in the CSSOM",description:"Currently, we know two ways to adjust our website styling from our JavaScript:",source:"@site/docs/intermediate-javascript/4_object-oriented-javascript-part-2/2c-accessing-style-sheets-with-CSSOM.md",sourceDirName:"intermediate-javascript/4_object-oriented-javascript-part-2",slug:"/intermediate-javascript/object-oriented-javascript-part-2/optional-accessing-stylesheets-in-the-cssom",permalink:"/intermediate-javascript/object-oriented-javascript-part-2/optional-accessing-stylesheets-in-the-cssom",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Optional: Accessing Stylesheets in the CSSOM",id:"optional-accessing-stylesheets-in-the-cssom",slug:"optional-accessing-stylesheets-in-the-cssom",hide_table_of_contents:!0,sidebar_position:2,day:"monday",type:"lesson",url:"https://github.com/epicodus-curriculum/javascript-full-stack/blob/main/2c_accessing_style_sheets_with_CSSOM.md"},sidebar:"intermediate-javascript",previous:{title:"Game of Choice - Part 1",permalink:"/intermediate-javascript/object-oriented-javascript-part-2/game-of-choice---part-1"},next:{title:"Switch Cases",permalink:"/intermediate-javascript/object-oriented-javascript-part-2/switch-cases"}},r={},h=[{value:"The CSSOM and a Review of Web APIs",id:"the-cssom-and-a-review-of-web-apis",level:2},{value:"Accessing and Updating our CSS Style Sheet(s)",id:"accessing-and-updating-our-css-style-sheets",level:2},{value:"Gotcha #1: Browser Extensions Can Change the Number of CSS Style Sheets in your Webpage",id:"gotcha-1-browser-extensions-can-change-the-number-of-css-style-sheets-in-your-webpage",level:3},{value:"Accessing the Rules in our Stylesheet",id:"accessing-the-rules-in-our-stylesheet",level:3},{value:"Gotcha #2: You Must Serve your Project to Access the <code>cssRules</code> Property of your Stylesheet",id:"gotcha-2-you-must-serve-your-project-to-access-the-cssrules-property-of-your-stylesheet",level:3},{value:"Accessing our Rules Again",id:"accessing-our-rules-again",level:3},{value:"Adding Two New CSS Rules with <code>CSSStyleSheet.insertRule()</code>",id:"adding-two-new-css-rules-with-cssstylesheetinsertrule",level:3},{value:"Removing Rules with <code>CSSStyleSheet.deleteRule()</code>",id:"removing-rules-with-cssstylesheetdeleterule",level:3},{value:"Gotcha #3: The Changing Index Locations of CSS Rules Can Lead to Unexpected Bugs",id:"gotcha-3-the-changing-index-locations-of-css-rules-can-lead-to-unexpected-bugs",level:3},{value:"A Review of the CSSOM Object Types and Properties Names",id:"a-review-of-the-cssom-object-types-and-properties-names",level:3},{value:"Summary",id:"summary",level:2}],c={toc:h},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Currently, we know two ways to adjust our website styling from our JavaScript: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Adjusting the ",(0,a.kt)("inlineCode",{parentName:"li"},"style")," attribute to set inline CSS styles."),(0,a.kt)("li",{parentName:"ul"},"Or adjusting styles by adding and removing ",(0,a.kt)("inlineCode",{parentName:"li"},"class")," attributes that have styles declared for them in our stylesheet. ")),(0,a.kt)("p",null,"What we don't know yet is how to access our stylesheet directly, and this is exactly what we'll learn how to do in this lesson. "),(0,a.kt)("p",null,"In the process we'll learn a bit about the CSSOM. Can you guess what CSSOM stands for? The ",(0,a.kt)("strong",{parentName:"p"},"CSSOM")," is the CSS Object Model, another Web API. It's just like the DOM, except instead of representing HTML as an object model, it handles representing our CSS as an object model. The CSSOM is how our web browser makes our project's CSS stylesheet something that we can access and manipulate with JavaScript \u2014 by representing the stylesheet as a series of nested objects. And just like with the DOM, the CSSOM is made up of many object types that we can learn to use in our code, and its data structure is a tree \u2014 a hierarchical collection of nodes."),(0,a.kt)("p",null,"At the end of this lesson, you'll likely still prefer to update your webpage's styles via setting and removing classes. In fact, I also recommend that approach as the easiest to implement. Why? It's because there are a few gotchas involved with accessing our stylesheets:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Your project may have multiple stylesheets, so you'll need to verify that you are working with the right one. "),(0,a.kt)("li",{parentName:"ul"},"We must serve our project (like with VS Code's Live Server extension) to access the stylesheet in order to avoid an issue with the Cross Origin Resource Sharing (CORS) security standard. We'll explain this briefly in this lesson, but cover CORS more in depth when we get to the Asynchrony and APIs course section."),(0,a.kt)("li",{parentName:"ul"},"The list of CSS rules for our stylesheet is a live updated list, which means its contents change as we add and remove rules, which can lead to bugs if we're not careful. ")),(0,a.kt)("p",null,"The goal of this lesson is to introduce ourselves to the CSSOM and understand how to access and update our stylesheets. To that end, we'll first start with a review of the Web APIs we've learned about, and see how the CSSOM fits in. Then, we'll get into accessing the right properties and calling the right methods to add and remove CSS rules from our style sheet. We'll learn about:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"document.styleSheets")," property that contains all of our CSS style sheets (as many as are in our project)."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheets.insertRule()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheets.deleteRule()")," methods."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheets.cssRules")," property which contains a live list (updated in real time) of CSS rules.")),(0,a.kt)("p",null,"You are welcome to code along with this lesson, or just read through it. We'll use our Address Book project to practice accessing and updating its stylesheet via the DevTools console."),(0,a.kt)("h2",{id:"the-cssom-and-a-review-of-web-apis"},"The CSSOM and a Review of Web APIs"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"The CSSOM is a Web API. Just like the DOM, the CSSOM is a specification that is made up of multiple interfaces (object types). Let's review all of this, starting with what Web APIs are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"We must use Web APIs to create interactive webpages.")," Web browsers do all the heavy lifting of processing and rendering the webpages we create with HTML, CSS, and JavaScript. Web browsers also manage the events that happen in the browser's webpage like a click of a button or a form submission. So if we want to write JavaScript to respond to events or change the look of our webpage, we must do this by using Web APIs \u2014 the web browser structures that are made available to developers so they can create interactive webpages."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"API is the acronym for application programming interface (API).")," ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"A simple example of an interface is a door knob, where the knob abstracts all of the complex inner workings of the latch into a simple tool that we can use to open the door. We don't need to know about how the latch works, we just need to know how to use the knob. "),(0,a.kt)("li",{parentName:"ul"},"Any interface used in computer programming is called an application programming interface, or API. The API lets us access complex and/or private code and use it in our own applications. "),(0,a.kt)("li",{parentName:"ul"},"Web APIs are APIs that specifically make web browser tools and structures available for developers to use in their websites. Here, too, developers don't need to worry about the complex inner workings of web browsers, they just need to learn how to call on the right objects, methods and properties to respond to an event, or change the webpage."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Web APIs have dedicated documentation in MDN.")," ",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API"},"Visit this link to see the documentation on Web APIs."),". These tools are standard across all modern web browsers, however not every tool is implemented in every browser, and some tools are new and experimental."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Web APIs are separated into two categories: specifications and interfaces.")," A specification describes what functionality or attributes a web tool must include. An example is the DOM. Specifications are typically made up of multiple interfaces. An interface is just an object type that handles one specific piece of functionality. The interfaces we've worked with so far belong to the DOM/HTML DOM: ",(0,a.kt)("inlineCode",{parentName:"li"},"Window"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Document"),", HTML element objects, ",(0,a.kt)("inlineCode",{parentName:"li"},"HTMLElement"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Element"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"EventTarget"),", and others. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Web browsers create an object model of a website's CSS when it renders the webpage in the browser.")," This object model is called the ",(0,a.kt)("strong",{parentName:"li"},"CSSOM"),", and it is made up of objects with properties and methods that we can use in our scripts to access and manipulate our webpage's CSS."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"The CSSOM specification describes the functionality that the CSS Object Model must include.")," When we visit ",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model"},"the documentation for the CSSOM on MDN")," we can see all of the many interfaces (object types) that make up the functionality of the CSSOM.")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/INTRO/week3-branching-looping-arrays/webapi-specifications-and-interfaces.png",alt:"This image is a graphic representation of the categorization of Web APIs into specifications and interfaces."})),(0,a.kt)("p",null,"It can be overwhelming to wrap your head around all of the object types and specifications out there for Web APIs. Honestly, you really shouldn't know them all by name, or understand how all of the objects relate to each other. What's important to have is a basic conceptual understanding of Web APIs, which we've just outlined above. This will help you be able to better navigate MDN and write search queries, which ultimately will help you become a more resourceful developer."),(0,a.kt)("p",null,"Beyond conceptually understanding web browser structures and tools (Web APIs), the most important thing here is to be familiar with the object types, methods, and properties that you need to make your code work. So, if the conceptual discussion of Web APIs is a bit too abstract for you, that is completely fine! You don't need to worry about it now. In time, this information will become second nature to you."),(0,a.kt)("h2",{id:"accessing-and-updating-our-css-style-sheets"},"Accessing and Updating our CSS Style Sheet(s)"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"To explore CSSOM tools, we'll use the final version of the Address Book project in the branch ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/epicodus-lessons/oop-address-book-v2/tree/8_adding_delete_functionality_and_polish"},(0,a.kt)("inlineCode",{parentName:"a"},"8_adding_delete_functionality_and_polish")),". Open your Address Book project in the browser, and then open your DevTools console. Then, input this code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets;\nStyleSheetList\xa0{0: CSSStyleSheet, 1: CSSStyleSheet, length: 2}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"styleSheets")," is a property of the ",(0,a.kt)("inlineCode",{parentName:"p"},"document")," object. The ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets")," property returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," object that contains one or more ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet")," objects. Each ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet")," object represents one stylesheet and contains the actual CSS rules in that sheet! "),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," property of the ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," object is always set to a number and it corresponds to how many style sheets are in your project. In our case ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"2"),", which corresponds to the two style sheets in our project: ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," and Bootstrap."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList"),' object is one of those array-like objects we learned about in the "Adding and Removing HTML Elements" lesson in the Arrays and Looping course section. With array-like objects, they have keys that are set to numbers that start at 0 and increment by one. This mimics the index positions of array elements that also start at 0 and increment by one. If we expand the ',(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," object, we can better see the key-value pairs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"StyleSheetList\xa0{\n  0: CSSStyleSheet {...}, \n  1: CSSStyleSheet {...}, \n  length: 2\n}\n")),(0,a.kt)("p",null,"Note that even though the keys ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," appear to be numbers, they are still in fact strings. And when accessing an object key that does not start with an alphabetic character, we must use bracket notation. Let's try using bracket notation to access individual ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet")," objects now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[0];\nCSSStyleSheet\xa0{ownerRule: null, cssRules: CSSRuleList, rules: CSSRuleList, type: 'text/css', href: 'https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css',\xa0\u2026}\n> document.styleSheets[1];\nCSSStyleSheet\xa0{ownerRule: null, type: 'text/css', href: 'file:///C:/Users/staff/Downloads/oop-address-book-v2/css/styles.css', ownerNode: link, parentStyleSheet: null,\xa0\u2026}\n")),(0,a.kt)("p",null,"There's a lot of information in each object! One helpful property to look at is ",(0,a.kt)("inlineCode",{parentName:"p"},"href"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property contains the source of the stylesheet and we can use it to verify which stylesheet is which:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[0].href;\n'https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css'\n> document.styleSheets[1].href;\n'file:///C:/Users/staff/Downloads/oop-address-book-v2/css/styles.css'\n")),(0,a.kt)("p",null,"This means that the Bootstrap stylesheet is located at the ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," index, and our custom stylesheet ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," is located at the ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," index. Or in other words, the property key for the Bootstrap stylesheet is ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", and the property key for the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,"Note that the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property for the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet will look different if you are serving your project with Live Share, or if you are opening your project from a Mac or Linux computer."),(0,a.kt)("p",null,"Let's pause for a second. Do you have more than just two stylesheets? Maybe the ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," property is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"3")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"4"),"? This means that there are additional stylesheets in your project, and this brings us to our first gotcha. "),(0,a.kt)("h3",{id:"gotcha-1-browser-extensions-can-change-the-number-of-css-style-sheets-in-your-webpage"},"Gotcha #1: Browser Extensions Can Change the Number of CSS Style Sheets in your Webpage"),(0,a.kt)("p",null,"I have ",(0,a.kt)("a",{parentName:"p",href:"https://chrome.google.com/webstore/detail/dark-mode/dmghijelimhndkbmpgbldicpogfkceaj?hl=en"},"a browser extension installed that creates a global dark theme")," that I can toggle on or off for any web page I visit. This extension creates a dark mode on any webpage I visit by actually adding a new style sheet to my webpage. So, when I access ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets")," after I've served my Mad Libs project, I actually have three ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet")," objects:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/INTRO/week3-branching-looping-arrays/3-cssstylesheet-objects-with-madlibs.png",alt:"This image shows the result of typing in `document.styleSheets` into the DevTools console: there's 3 separate `CSSStyleSheet` objects, each representing a different style sheet in our webpage."})),(0,a.kt)("p",null,"While I might have three stylesheets, you might just have two, or you might have four! The important implication here is that any user accessing our webpage can have any number of stylesheets, which means that the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," file that we want to access could be at any location in the list of stylesheets. We need to always keep this in mind during development."),(0,a.kt)("p",null,"So, the big question here is which stylesheet is ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css"),"?"),(0,a.kt)("p",null,"The easiest way to verify that we're targeting ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," and not another sheet is by looking at the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property of each style sheet. Check out the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> document.styleSheets[0].href.includes("styles.css");\nfalse\n> document.styleSheets[1].href.includes("styles.css");\ntrue\n')),(0,a.kt)("p",null,"By calling ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype.includes()")," on the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property of each stylesheet object, and passing in the argument ",(0,a.kt)("inlineCode",{parentName:"p"},'"styles.css"'),", we can see if the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," includes the name of the file we want to target. In this case, we've determined that the stylesheet at index 1 is ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css"),". This means that the property key of ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),". "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Notably, this may not be true for you.")," Depending on how many stylesheets you have in your project, and the order in which they are listed, ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," may not be at index 1. ",(0,a.kt)("strong",{parentName:"p"},"For the purposes of this lesson, we'll always assume that ",(0,a.kt)("inlineCode",{parentName:"strong"},"styles.css")," is at index 1 in the examples we work through.")," This means that our stylesheet ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," is accessed with ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets[1]"),".  "),(0,a.kt)("p",null,"In order to continually work with the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet, we need to get the name of the key that contains that style sheet so we can access it over and over again, wherever we need to in our code. In our case, the key is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,"We also need to be able to check a variable number of stylesheet objects within the ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," collection. To do all of the above, we'll need a loop and branching, and make sure to save the key of the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet. Our next step is to create a new function that we'll add to our user interface logic. We can try this out in the DevTools first: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> function locateStyleSheet() {\n  const styleSheetArray = Array.from(document.styleSheets);\n  let indexLocation;\n  styleSheetArray.forEach(function(styleSheet, index) {\n    if (styleSheet.href) {\n      if (styleSheet.href.includes("styles.css")) {\n        indexLocation = index;\n      }\n    }\n  });\n  return indexLocation;\n}\n> locateStyleSheet();\n1\n')),(0,a.kt)("p",null,"Let's break down the new ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"First we turn the ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," object into an array by passing ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets")," into the ",(0,a.kt)("inlineCode",{parentName:"p"},"Array.from()")," static method, and saving the result in the variable ",(0,a.kt)("inlineCode",{parentName:"p"},"styleSheetArray"),". This will enable us to use array methods on the list of stylesheets. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Next, we initialize an empty variable called ",(0,a.kt)("inlineCode",{parentName:"p"},"indexLocation"),". This is the variable that will contain the property key of the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet object. At the end of the function, we return ",(0,a.kt)("inlineCode",{parentName:"p"},"indexLocation")," from our function. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Next, we loop over our ",(0,a.kt)("inlineCode",{parentName:"p"},"styleSheetArray")," array with ",(0,a.kt)("inlineCode",{parentName:"p"},"Array.prototype.forEach()"),". Remember that ",(0,a.kt)("inlineCode",{parentName:"p"},"Array.prototype.forEach()")," takes a callback function as an argument. We're passing in an anonymous function expression as the callback, which is highlighted below:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// this is the callback function\n// passed into styleSheetArray.forEach(...);\nfunction(styleSheet, index) {\n  if (styleSheet.href) {\n    if (styleSheet.href.includes("styles.css")) {\n      indexLocation = index;\n    }\n  }\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The callback function for ",(0,a.kt)("inlineCode",{parentName:"p"},"Array.prototype.forEach()")," has access to two optional parameters: one that gives us access to the current element in the array (the ",(0,a.kt)("inlineCode",{parentName:"p"},"styleSheet")," parameter), and the other that gives us access to the current element's index location (the ",(0,a.kt)("inlineCode",{parentName:"p"},"index")," parameter). Often these parameters are call ",(0,a.kt)("inlineCode",{parentName:"p"},"element")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"index"),", but we can name them whatever we want. We're using both parameters so that we can access each stylesheet (the elements in our array) and their index location (which corresponds to their property key in the ",(0,a.kt)("inlineCode",{parentName:"p"},"StyleSheetList")," object).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Within the callback function, we have an ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement that first checks to see if there's any value for the current stylesheet's ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property. We're harnessing JavaScript's concept of truthy values, and we're using it to weed out any stylesheets that have ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," value for the ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property. Why? If we try to call a string method on ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),", JavaScript will throw an error and stop the execution of our code. So, if our styleSheet has an ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property with any value, we then move onto the second, nested ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"In the second, nested ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement, we check whether the stylesheet's ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property includes ",(0,a.kt)("inlineCode",{parentName:"p"},'"styles.css"'),", and if so to update the value of our ",(0,a.kt)("inlineCode",{parentName:"p"},"indexLocation")," variable with the index. If the stylesheet's ",(0,a.kt)("inlineCode",{parentName:"p"},"href")," property does not have ",(0,a.kt)("inlineCode",{parentName:"p"},'"styles.css"')," in it, we do nothing and the loop continues."))),(0,a.kt)("p",null,"Let's see how we can actually put the ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function to use. In the DevTools, we'll call the ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function and saved the returned result in a variable, and then we'll use that variable to access ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> const indexOfCustomStyles = locateStyleSheet();\n> indexOfCustomStyles;\n1\n> document.styleSheets[indexOfCustomStyles];\nCSSStyleSheet\xa0{ownerRule: null, type: 'text/css', href: 'file:///C:/Users/staff/Downloads/oop-address-book-v2/css/styles.css', ownerNode: link, parentStyleSheet: null,\xa0\u2026}\n")),(0,a.kt)("p",null,"Notably, ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets[indexOfCustomStyles]")," returns the same result as ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets[1]"),", since ",(0,a.kt)("inlineCode",{parentName:"p"},"indexOfCustomStyles")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,"Now with the functionality of the ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function, we can quickly find the key (or index location) of our custom style sheet ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css"),", no matter how many other stylesheets there are. The ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function specifically enables us to find the index of ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," ",(0,a.kt)("strong",{parentName:"p"},"dynamically"),". When we find values and results dynamically, we avoid using hardcoded values, and instead use algorithms to generate the values we need. "),(0,a.kt)("p",null,"Just to reiterate, here's a hardcoded index:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// hardcoded index\n> document.styleSheets[1];\n")),(0,a.kt)("p",null,"And here's a dynamically generated index:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// dynamic index\n> const indexOfCustomStyles = locateStyleSheet();\n> indexOfCustomStyles;\n> document.styleSheets[indexOfCustomStyles];\n")),(0,a.kt)("p",null,"Next up, let's explore how to access the rules in our ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet."),(0,a.kt)("h3",{id:"accessing-the-rules-in-our-stylesheet"},"Accessing the Rules in our Stylesheet"),(0,a.kt)("p",null,"Now that we have access to our stylesheet, let's access the rules inside of it. To do this, we'll use properties and methods from the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet")," object, which will let us look at all of the rules listed in our style sheets, as well as delete and insert rules:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.cssRules")," property lets us access all of the rules listed in the style sheet."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.deleteRule()")," method lets us remove a CSS rule from the style sheet."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.insertRule()")," method lets us add a CSS rule from the style sheet.")),(0,a.kt)("p",null,"We'll start by looking at all of the rules in the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.cssRules")," property.\nRemember that in this lesson's examples, we're assuming that the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet is at index 1 (or, its property key is ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),") and can be accessed with ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets[1]"),"."),(0,a.kt)("p",null,"We can access the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property in a couple of ways. First by accessing the ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet, and then the rules:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> const myCustomStyles = document.styleSheets[1];\n> myCustomStyles.cssRules;\n")),(0,a.kt)("p",null,"Or by accessing the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," by chaining property accessors:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\n")),(0,a.kt)("p",null,"And what do we get?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nUncaught DOMException: Failed to read the 'cssRules' property from 'CSSStyleSheet': Cannot access rules at <anonymous>:1:25\n")),(0,a.kt)("p",null,"Uh-oh! We get a ",(0,a.kt)("inlineCode",{parentName:"p"},"DOMException")," error. Well, you'll only get this error if your project is not being served by any web server, like Live Server. This brings us to our next gotcha."),(0,a.kt)("h3",{id:"gotcha-2-you-must-serve-your-project-to-access-the-cssrules-property-of-your-stylesheet"},"Gotcha #2: You Must Serve your Project to Access the ",(0,a.kt)("inlineCode",{parentName:"h3"},"cssRules")," Property of your Stylesheet"),(0,a.kt)("p",null,"This gotcha is caused by two things. First of all,  the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property is live-updated. This means that it's not just static data, but data that's continuously being updated. In other words, any time we add or remove a rule from our style sheets, the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property automatically reflects this change."),(0,a.kt)("p",null,"The second reason behind the ",(0,a.kt)("inlineCode",{parentName:"p"},"DOMException")," error has to do with the Cross Origin Resource Sharing (CORS) security standard that all modern browsers implement. We will spend time learning about CORS when we query APIs with asynchronous JavaScript in the 6th course section of the program, so we won't get into the weeds of understanding CORS right now. We'll just focus on incorporating the solution in our projects so we can start accessing and updating our CSS rules."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The solution for accessing the ",(0,a.kt)("inlineCode",{parentName:"strong"},"CSSStyleSheet.cssRules")," property is to simply serve our project with Live Share. Even when you are working alone, you'll need to serve your project with Live Share to access the ",(0,a.kt)("inlineCode",{parentName:"strong"},"CSSStyleSheet.cssRules")," property.")," If we do not serve our project, the CORS security standard will prevent the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property from getting an updated rule list."),(0,a.kt)("p",null,"When we serve our project with LiveShare or otherwise, the URL will come from ",(0,a.kt)("inlineCode",{parentName:"p"},"localhost"),". For my Address Book project, the URL looks like ",(0,a.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:5501/index.html"),". In my case, ",(0,a.kt)("inlineCode",{parentName:"p"},"127.0.0.1")," is the same as ",(0,a.kt)("inlineCode",{parentName:"p"},"localhost"),", so if I am using Live Server to serve my project, I can also navigate to ",(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:5501/index.html")," to access it."),(0,a.kt)("p",null,"The opposite of serving a project is just opening a local file directly in the browser. For example, on my Windows computer, if I open my Address Book html file in the browser, the URL will state this ",(0,a.kt)("inlineCode",{parentName:"p"},"file:///C:/Users/staff/Desktop/oop-address-book-v2/index.html"),". A URL that starts with ",(0,a.kt)("inlineCode",{parentName:"p"},"file:///")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"C:/Users/...")," indicates that we've simply opened a local file in the browser from a Windows computer, and we're not serving the project with a web server."),(0,a.kt)("p",null,"If you are coding along with this lesson, make sure that your project is opened in the browser with Live Server before continuing."),(0,a.kt)("h3",{id:"accessing-our-rules-again"},"Accessing our Rules Again"),(0,a.kt)("p",null,"With our project served, we can now access ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," to view the rules in ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css"),". We'll also add a few new ones for practice. Again, in this lesson, we're assuming that ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," is located at index 1 of ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nCSSRuleList {0: CSSStyleRule, length: 1}\n  0: CSSStyleRule {selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }', \u2026}\n  length: 1\n  [[Prototype]]: CSSRuleList\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSRuleList")," object which contains a collection of ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleRule")," objects, each of which represents an individual rule."),(0,a.kt)("p",null,"Or in other words, every CSS rule in any stylesheet object is turned into a ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleRule")," object, and added to the list of CSS rules that's saved in the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property, which is a ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSRuleList")," object. "),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet only has one rule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-css"},".hidden {\n  display: none;\n}\n")),(0,a.kt)("p",null,"Which means that our ",(0,a.kt)("inlineCode",{parentName:"p"},"style.css")," stylesheet object only has one ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleRule")," object, which we can access with bracket notation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules[0];\nCSSStyleRule\xa0{selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }',\xa0\u2026}\n")),(0,a.kt)("p",null,"To access the exact text of our ",(0,a.kt)("inlineCode",{parentName:"p"},".hidden")," rule, we'll need to do access its ",(0,a.kt)("inlineCode",{parentName:"p"},"cssText")," property:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules[0].cssText;\n'.hidden { display: none; }'\n")),(0,a.kt)("h3",{id:"adding-two-new-css-rules-with-cssstylesheetinsertrule"},"Adding Two New CSS Rules with ",(0,a.kt)("inlineCode",{parentName:"h3"},"CSSStyleSheet.insertRule()")),(0,a.kt)("p",null,"Let's add a new rule to our ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet. To do this, we'll call the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.insertRule()")," method, which is called on the stylesheet object, and not on its list of CSS rules found in the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> const myCustomStyles = document.styleSheets[1]\n> myCustomStyles.insertRule('body { background-color:'red' }');\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.insertRule()")," method takes a string as an argument that contains the CSS rule. And we've done just that: take a CSS rule and add quotes around to make it a string. "),(0,a.kt)("p",null,"We'll know that we've successfully added a new rule if the background color of our Address Book project turns red! We can also check that our ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property now has two rules listed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nCSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, length: 2}\n  0: CSSStyleRule {selectorText: 'body', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'body { background-color:'red'; }', \u2026}\n  1: CSSStyleRule {selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }', \u2026}\n  length: 2\n  [[Prototype]]: CSSRuleList\n")),(0,a.kt)("p",null,"Notice that our new CSS rule has been added to the top of the list of CSS rules, at index 0. This is the default behavior of the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.insertRule()")," method. However, we can include an optional second argument to specify which index location we want to add the rule. Let's try that out next. "),(0,a.kt)("p",null,"We'll add our next rule to the very end of the list of CSS rules:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> const endOfListIndex = document.styleSheets[1].cssRules.length;\n> document.styleSheets[1].insertRule('div.container { color:'green'; font-weight: 600 }', endOfListIndex);\n")),(0,a.kt)("p",null,"First, we accessed the length of the ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property (which corresponds to how many rules it has), and then we've passed that in as the second argument in the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.insertRule()")," method call. This adds the new rule for our div with the ",(0,a.kt)("inlineCode",{parentName:"p"},".container")," class at the end of our list of rules. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nCSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, 3: CSSStyleRule, length: 3}\n  0: CSSStyleRule {selectorText: 'body', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'body { background-color:'red'; }', \u2026}\n  1: CSSStyleRule {selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }', \u2026}\n  2: CSSStyleRule {selectorText: 'div.container', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'div.container { color:'green'; font-weight: 600; }', \u2026}\n  length: 3\n  [[Prototype]]: CSSRuleList\n")),(0,a.kt)("p",null,"Next up, let's explore how to remove rules. "),(0,a.kt)("h3",{id:"removing-rules-with-cssstylesheetdeleterule"},"Removing Rules with ",(0,a.kt)("inlineCode",{parentName:"h3"},"CSSStyleSheet.deleteRule()")),(0,a.kt)("p",null,"We use the ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheet.deleteRule()")," method. This method take an index as an argument. Let's delete the red background color. First, let's verify the index location of this rule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nCSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, 3: CSSStyleRule, length: 3}\n  0: CSSStyleRule {selectorText: 'body', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'body { background-color:'red'; }', \u2026}\n  1: CSSStyleRule {selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }', \u2026}\n  2: CSSStyleRule {selectorText: 'div.container', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'div.container { color:'green'; font-weight: 600; }', \u2026}\n  length: 3\n  [[Prototype]]: CSSRuleList\n")),(0,a.kt)("p",null,"We should be able to tell that the background color is set in the rule at index 0. With that information we can remove the rule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets.deleteRule(0);\nundefined\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"CSSStyleSheets.deleteRule()")," method doesn't return anything, so the console prints ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("p",null,"We should be able to verify that our rule deletion worked by the change in background color of our Address Book project. Now it should be white again."),(0,a.kt)("p",null,"However, let's double-check our ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," property to verify as well. This will reveal the next gotcha!"),(0,a.kt)("h3",{id:"gotcha-3-the-changing-index-locations-of-css-rules-can-lead-to-unexpected-bugs"},"Gotcha #3: The Changing Index Locations of CSS Rules Can Lead to Unexpected Bugs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules;\nCSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, 3: CSSStyleRule, length: 3}\n  0: CSSStyleRule {selectorText: '.hidden', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: '.hidden { display: none; }', \u2026}\n  1: CSSStyleRule {selectorText: 'div.container', style: CSSStyleDeclaration, styleMap: StylePropertyMap, type: 1, cssText: 'div.container { color:'green'; font-weight: 600; }', \u2026}\n  length: 2\n  [[Prototype]]: CSSRuleList\n")),(0,a.kt)("p",null,"Notice how the keys for our CSS rules have shifted! The ",(0,a.kt)("inlineCode",{parentName:"p"},".hidden")," rule is now at index 0, and the ",(0,a.kt)("inlineCode",{parentName:"p"},"div.container")," rule is now at index 1. This is another gotcha when adding and removing CSS rules: the index locations of individual rules change when we add and remove rules. This happens because ",(0,a.kt)("inlineCode",{parentName:"p"},"cssRules")," is a live updated property that always shows an updated list, which includes updates index locations for CSS rules as new ones get added, and others are removed."),(0,a.kt)("p",null,"The implication for us developers is that this makes targeting the right rule a bit more cumbersome of a process, because we can't hardcode index values. Instead, we need to generate them dynamically. For example, we might need to write a similar function as we did with the ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function to make sure we're targeting the right rule at the right index location."),(0,a.kt)("p",null,"Or, we could be very diligent about only adding and removing new rules to the beginning of the list at index 0, so that we could still hardcode. However, this would only be viable if we're adding and removing just one rule, and it's not code that is very scalable. What happens if we need to add and remove multiple rules? Well, then we're back to needing a solution similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"locateStyleSheet()")," function."),(0,a.kt)("p",null,"In the end, the lesson here is that these changing indices are something that we have to consider as a developer. In fact, all of the gotchas we learned about are factors that we need to consider when we're working with the CSSOM to directly access and update our stylesheets."),(0,a.kt)("h3",{id:"a-review-of-the-cssom-object-types-and-properties-names"},"A Review of the CSSOM Object Types and Properties Names"),(0,a.kt)("p",null,"With a statement like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> document.styleSheets[1].cssRules[0].cssText;\n")),(0,a.kt)("p",null,"We've possibly gone farther than we ever have in a series of nested objects. If you are anything like me, this is definitely confusing. "),(0,a.kt)("p",null,"Also, with the CSSOM being so new to us, we're learning the properties and methods we need to call, but we're also learning about new object types within the CSSOM. Differentiating between the property names and the object types is also confusing. "),(0,a.kt)("p",null,"So, let's do a review of the new objects types and properties that we've worked with in this lesson."),(0,a.kt)("p",null,"Check out the following image that shows CSSOM object types as they relate to an actual CSS stylesheet. Take note that the CSS stylesheet in the image below is fictional, and does not belong to the Address Book project. "),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/INTRO/week3-branching-looping-arrays/nested-css-rule-objects-CSSOM.png",alt:"This image shows all of the nested objects that we automatically are working with when we input `document.styleSheets[0]`."})),(0,a.kt)("p",null,"In the image to the right, we can see how all of these object types nest inside of each other. In the image on the left, we see a series of nested boxes that visualize what each object type corresponds to in the CSS stylesheet."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The ",(0,a.kt)("inlineCode",{parentName:"strong"},"StyleSheetList")," object contains a list of all stylesheets in a project.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Each stylesheet in the ",(0,a.kt)("inlineCode",{parentName:"li"},"StyleSheetList")," is represented by a ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet")," object."),(0,a.kt)("li",{parentName:"ul"},"We access the ",(0,a.kt)("inlineCode",{parentName:"li"},"StyleSheetList")," via ",(0,a.kt)("inlineCode",{parentName:"li"},"document.styleSheets"),".")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The ",(0,a.kt)("inlineCode",{parentName:"strong"},"CSSStyleSheet")," object represents a single CSS stylesheet.")," "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We access a ",(0,a.kt)("inlineCode",{parentName:"li"},"StyleSheetList")," via ",(0,a.kt)("inlineCode",{parentName:"li"},"document.styleSheets[index]"),", where ",(0,a.kt)("inlineCode",{parentName:"li"},"index")," is the index of the stylesheet we want to target. "),(0,a.kt)("li",{parentName:"ul"},"We can access various helpful properties and methods from this object:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.cssRules")," contains a list of all CSS rules in the stylesheet."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.href")," contains the path to the location of the stylesheet."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.insertRule()")," is a method to add a rule to the list of CSS rules."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet.deleteRule()")," is a method to remove a rule from the list of CSS rules.")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The ",(0,a.kt)("inlineCode",{parentName:"strong"},"CSSRuleList")," object contains a list of CSS rules in a stylesheet.")," "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Each CSS rule in the ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSRuleList")," is represented by a ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSRule")," object."),(0,a.kt)("li",{parentName:"ul"},"We access the ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSRuleList")," via ",(0,a.kt)("inlineCode",{parentName:"li"},"document.styleSheets[index].cssRules"),", where ",(0,a.kt)("inlineCode",{parentName:"li"},"index")," is the index of the stylesheet we want to target, and ",(0,a.kt)("inlineCode",{parentName:"li"},"cssRules")," is a property of the ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSStyleSheet")," object.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The ",(0,a.kt)("inlineCode",{parentName:"strong"},"CSSRule")," object represents a single CSS rule.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We access the ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSRule")," via ",(0,a.kt)("inlineCode",{parentName:"li"},"document.styleSheets[index1].cssRules[index2]"),", where ",(0,a.kt)("inlineCode",{parentName:"li"},"index1")," is the index of the stylesheet we want to target, and ",(0,a.kt)("inlineCode",{parentName:"li"},"index2")," is the index of the single CSS rule that we want to target."),(0,a.kt)("li",{parentName:"ul"},"We can access various properties in the ",(0,a.kt)("inlineCode",{parentName:"li"},"CSSRule")," object, like:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CSSRule.cssText")," which contains the CSS rule as a string.")))),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"In this lesson we learned how to access the CSSOM, including how to view, add, and remove CSS rules. In the process, we reviewed browser Web APIs and learned how the CSSOM fits in. We also learned a few important gotchas when writing code that accesses a specific stylesheet and updates specific CSS rules:  "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Users who visit your site may have additional stylesheets that are added by browser extensions. So, you'll need to be sure to locate your custom stylesheet dynamically, and not hard code an index value that could change."),(0,a.kt)("li",{parentName:"ul"},"In order to access the live-updated list of CSS rules in your stylesheet, you must serve your project (like with VS Code's Live Server extension) in order to avoid an issue with the Cross Origin Resource Sharing (CORS) security standard. (We'll learn more about this standard in the Asynchrony and APIs course section)."),(0,a.kt)("li",{parentName:"ul"},"The list of CSS rules for our stylesheet is a live updated list, which means its contents change as we add and remove rules. The big implication for us is that the indexes of the contents change, and we use these indexes to remove rules, and sometimes when adding rules. Here, too, we can't always rely on hardcoded indexes in our code and expect it to function without error.")),(0,a.kt)("p",null,"As stated at the very beginning of this lesson, because of these gotchas it's much easier and just as effective to add and remove CSS styling by adding and removing classes with ",(0,a.kt)("inlineCode",{parentName:"p"},"Element.setAttribute()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Element.removeAttribute()"),". It will work for the majority of our use cases. But the truth is that we've only covered one small aspect of the CSSOM by looking at ",(0,a.kt)("inlineCode",{parentName:"p"},"document.styleSheets"),", and there are more tools to learn about for manipulating the CSSOM. "),(0,a.kt)("p",null,"If you are an aspiring front-end developer, I recommend that you continue research on the CSSOM and  what more you can do with it. Here are a few resources to work through:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/"},'"An Introduction and Guide to the CSS Object Model (CSSOM)" by css-tricks.com')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work"},'"Populating the page: how browsers work" by MDN')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model"},"The CSSOM Specification on MDN"))),(0,a.kt)("p",null,"If you want a challenge, try updating the show/hide functionality for contact details in the Address Book project to directly add and remove the ",(0,a.kt)("inlineCode",{parentName:"p"},".hidden")," rule from the project's ",(0,a.kt)("inlineCode",{parentName:"p"},"styles.css")," stylesheet."))}d.isMDXComponent=!0}}]);