"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[24458],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),m=a,d=h["".concat(l,".").concat(m)]||h[m]||u[m]||r;return n?o.createElement(d,i(i({ref:t},c),{},{components:n})):o.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},42404:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=n(7896),a=(n(2784),n(30876));const r={title:"Constructors and Prototypes",id:"constructors-and-prototypes",slug:"constructors-and-prototypes",hide_table_of_contents:!0,sidebar_position:5,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/javascript-full-stack/blob/main/0e_constructors_and_prototypes.md"},i=void 0,s={unversionedId:"intermediate-javascript/object-oriented-javascript/constructors-and-prototypes",id:"intermediate-javascript/object-oriented-javascript/constructors-and-prototypes",title:"Constructors and Prototypes",description:"In this lesson, we're going to explore how JavaScript uses constructors as blueprints for the creation of many new objects of the same type, and prototypes for adding properties and methods to objects.",source:"@site/docs/intermediate-javascript/3_object-oriented-javascript/0e-constructors-and-prototypes.md",sourceDirName:"intermediate-javascript/3_object-oriented-javascript",slug:"/intermediate-javascript/object-oriented-javascript/constructors-and-prototypes",permalink:"/intermediate-javascript/object-oriented-javascript/constructors-and-prototypes",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Constructors and Prototypes",id:"constructors-and-prototypes",slug:"constructors-and-prototypes",hide_table_of_contents:!0,sidebar_position:5,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/javascript-full-stack/blob/main/0e_constructors_and_prototypes.md"},sidebar:"intermediate-javascript",previous:{title:"Literal Notation Versus Constructors",permalink:"/intermediate-javascript/object-oriented-javascript/literal-notation-versus-constructors"},next:{title:"Constructor and Prototype Methods",permalink:"/intermediate-javascript/object-oriented-javascript/constructor-and-prototype-methods"}},l={},p=[{value:"Constructors",id:"constructors",level:2},{value:"When to Use Constructor Functions",id:"when-to-use-constructor-functions",level:3},{value:"Using a Constructor Function",id:"using-a-constructor-function",level:3},{value:"Array-Like Objects",id:"array-like-objects",level:3},{value:"Object Types versus Object Instances",id:"object-types-versus-object-instances",level:3},{value:"Important Takeaways So Far",id:"important-takeaways-so-far",level:3},{value:"Creating a Custom Constructor Function and Object Type",id:"creating-a-custom-constructor-function-and-object-type",level:3},{value:"Prototypes",id:"prototypes",level:2},{value:"Adding Methods to the <code>Dog</code> Prototype",id:"adding-methods-to-the-dog-prototype",level:3},{value:"Prototype Chain",id:"prototype-chain",level:3},{value:"Summary",id:"summary",level:2},{value:"More Resources",id:"more-resources",level:3}],c={toc:p},h="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this lesson, we're going to explore how JavaScript uses constructors as blueprints for the creation of many new objects of the same type, and prototypes for adding properties and methods to objects."),(0,a.kt)("p",null,"Let's start by taking a look at how we can use constructors with built-in JavaScript objects."),(0,a.kt)("h2",{id:"constructors"},"Constructors"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#creating_strings"},"MDN documentation for strings")," covers 4 ways to create a string:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Strings can be created as primitives, from string literals, or as objects, using the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor:")),(0,a.kt)("blockquote",null,(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const string1 = \"A string primitive\";\nconst string2 = 'Also a string primitive';\nconst string3 = `Yet another string primitive`;\n"))),(0,a.kt)("blockquote",null,(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const string4 = new String("A String object");\n'))),(0,a.kt)("p",null,"We haven't yet learned about using backticks for strings (the third example), and we won't worry about that for now. (Of course, you are welcome to explore this on your own.) What we're interested in is using the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor like we see in the very last example. ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," is a constructor function that allows us to create string objects. A ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/Constructor"},(0,a.kt)("strong",{parentName:"a"},"constructor"))," is a function that can be invoked using the ",(0,a.kt)("inlineCode",{parentName:"p"},"new")," keyword to create new objects of a specific type."),(0,a.kt)("p",null,"We often say that the constructor function is the blueprint for a type of object. A blueprint is a design of something, but notably not the thing itself. This is true for constructor functions. When we create a constructor function, we are defining what the object should look like, meaning what properties and methods it should have. "),(0,a.kt)("p",null,"Then, when we call (invoke) the constructor function, we're asking it to create an actual object that looks exactly like the blueprint. This is just what we're doing when we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor function \u2014 we're creating a string that has access to all of the properties and methods that strings should have:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> const string4 = new String("A String object");\n> string4.toUpperCase();\n"A STRING OBJECT"\n> "This is " + string4.toLowerCase() + ".";\n"This is a string object."\n')),(0,a.kt)("p",null,"Previously, we have created strings simply by adding quotes ",(0,a.kt)("inlineCode",{parentName:"p"},'" "')," around the characters we want to identify as strings. This is called ",(0,a.kt)("strong",{parentName:"p"},"literal notation"),". It triggers JavaScript to create a string primitive, which JavaScript then implicitly converts into an object so that it can have access to properties and methods, like ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype.charAt()"),". "),(0,a.kt)("p",null,"When JavaScript turns the string primitive into an object, it does so using the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor function. This process is true for every primitive that JavaScript implicitly turns into an object. To understand this process more in depth, ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Glossary/Primitive#autoboxing_primitive_wrapper_objects_in_javascript"},"visit this documentation on primitive wrapper objects"),". "),(0,a.kt)("p",null,"To visually identify constructor functions, they are conventionally named with a capitalized first letter. For example, these are the constructor functions for strings, numbers, and booleans:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// using constructor functions\n> const myCodeSchool = new String("Epicodus");\n> const myFavNumber = new Number(22);\n> const doILikePuppies = new Boolean(true);\n')),(0,a.kt)("p",null,"The constructor functions for ",(0,a.kt)("inlineCode",{parentName:"p"},"String()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Number()"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean()")," are not just for JavaScript to use under the hood \u2014 we can also use them directly in our code! That said, it is not a common practice. Generally speaking, if an object can be created with literal notation, it is usually easier and more common to use literal notation to create an object of that type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// using literal notation\n> const myCodeSchool = "Epicodus";\n> const myFavNumber = 22;\n> const doILikePuppies = true;\n')),(0,a.kt)("p",null,"So when might we use a constructor function?"),(0,a.kt)("h3",{id:"when-to-use-constructor-functions"},"When to Use Constructor Functions"),(0,a.kt)("p",null,"Almost every built-in JavaScript object has a constructor function that we can use to create an object of that type. One notable exception is ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math#description"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"Math")," object"),"). In many cases, we can only create a specific type of object by using its constructor function. Some examples include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#examples"},"The ",(0,a.kt)("inlineCode",{parentName:"a"},"Date")," object.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},"The ",(0,a.kt)("inlineCode",{parentName:"a"},"Map")," object.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#examples"},"The ",(0,a.kt)("inlineCode",{parentName:"a"},"Error")," object."))),(0,a.kt)("p",null,"You may not have worked with the above objects before, and you don't have to start now! These are just examples if you want to explore more."),(0,a.kt)("p",null,"In this section, we'll spend most of the time focusing on how to create constructor functions to define the blueprint of a custom object. We'll then learn how to call on this constructor function to create multiple objects of that same type. "),(0,a.kt)("p",null,"Before we get into that, let's learn a bit more about how to use constructor functions for built-in JavaScript objects."),(0,a.kt)("h3",{id:"using-a-constructor-function"},"Using a Constructor Function"),(0,a.kt)("p",null,"Let's use the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor function to create a new string. Put the following code into the DevTools console:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let testGreeting = new String();\nundefined\n> testGreeting;\nString {" "}\n  length: 0, \n  [[Prototype]]: String, \n  [[PrimitiveValue]]: ""\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting")," variable has been set to a ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object with an empty string inside of it. To see the properties of this object, we expand it in the DevTools console by clicking the arrow to the left of ",(0,a.kt)("inlineCode",{parentName:"p"},'String {" "}'),"."),(0,a.kt)("p",null,"Now try this out:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let testGreeting2 = new String("Hello!");\nundefined\n> testGreeting2;\nString {"Hello!"}\n  0: "H", \n  1: "e", \n  2: "l", \n  3: "l", \n  4: "o", \n  5: "!", \n  length: 6, \n  [[Prototype]]: String, \n  [[PrimitiveValue]]: "Hello!"\n')),(0,a.kt)("p",null,"In both of these examples, we see the ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor is called with the ",(0,a.kt)("inlineCode",{parentName:"p"},"new")," keyword, and it returns a string object. These objects have 3 properties: ",(0,a.kt)("inlineCode",{parentName:"p"},"length"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"[[PrimitiveValue]]"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"length")," lists the number of characters in a string. Note that this property isn't included for every built-in JavaScript object. For example, numbers do not have a ",(0,a.kt)("inlineCode",{parentName:"li"},"length")," property, but arrays do."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[[Prototype]]")," points to the object's blueprint. In this example, we can see ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," listed as the value, which means the ",(0,a.kt)("inlineCode",{parentName:"li"},"testGreeting")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"testGreeting2")," objects were both created from the blueprint for the ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," object type. Note that you can expand the ",(0,a.kt)("inlineCode",{parentName:"li"},"[[Prototype]]")," property and you'll see a list of ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," properties and methods. As we'll learn later, JavaScript objects share functionality through prototypes."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"[[PrimitiveValue]]")," lists the value of the corresponding primitive. This only exists for JavaScript primitives that are turned into objects, which includes all primitives except for ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"undefined"),".")),(0,a.kt)("p",null,"If we wanted to access these properties, we'd do so like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// length\n> testGreeting2.length;\n6\n// [[Prototype]]\n> testGreeting2.__proto__;\nString\xa0{'', constructor: \u0192, anchor: \u0192, big: \u0192, blink: \u0192,\xa0\u2026}\n// [[PrimitiveValue]]\n> testGreeting2.valueOf();\n\"Hello!\"\n")),(0,a.kt)("p",null,"These same properties can be found on a string primitive that we create with literal notation, and that JavaScript then implicitly turns into an object. Let's see how this works. First, we'll create a string:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> const myStr = "Hello!";\nundefined\n')),(0,a.kt)("p",null,"Then we'll access the number of characters in the string through the ",(0,a.kt)("inlineCode",{parentName:"p"},"length")," property:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> myStr.length;\n6\n")),(0,a.kt)("p",null,"To access the ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," property of ",(0,a.kt)("inlineCode",{parentName:"p"},"myStr"),", we'll access the ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property:  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> myStr.__proto__;\nString\xa0{'', constructor: \u0192, anchor: \u0192, big: \u0192, blink: \u0192,\xa0\u2026}\n")),(0,a.kt)("p",null,"To access the primitive value of the string, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype.valueOf()")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> myStr.valueOf(); \n"Hello!"\n')),(0,a.kt)("p",null,"It may seem odd to access the primitive value of ",(0,a.kt)("inlineCode",{parentName:"p"},"myStr"),", a variable holding a primitive value, but what's happening here is that ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype.valueOf()")," is accessing the primitive value of the string object that ",(0,a.kt)("inlineCode",{parentName:"p"},"myStr")," is turned into. If that feels confusing, well, that makes sense. The whole process of changing primitives into objects happens out of sight, which makes that process harder to understand. For better or worse, with some JavaScript you just have to accept that that's how it works. "),(0,a.kt)("h3",{id:"array-like-objects"},"Array-Like Objects"),(0,a.kt)("p",null,"There's one more thing to note about the string object that's returned from he ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," constructor: it is an ",(0,a.kt)("strong",{parentName:"p"},"array-like object"),". To understand this, let's revisit our ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let testGreeting2 = new String("Hello!");\nundefined\n> testGreeting2;\nString { Hello! }\n  0: "H", \n  1: "e", \n  2: "l", \n  3: "l", \n  4: "o", \n  5: "!", \n  length: 6, \n  [[Prototype]]: String, \n  [[PrimitiveValue]]: "Hello!"\n')),(0,a.kt)("p",null,"Notice that for ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2"),", when we provided the value ",(0,a.kt)("inlineCode",{parentName:"p"},'"Hello!"')," as the argument, the constructor creates properties for the index positions of each character. These properties allow us to use bracket notation to access the characters in a string by their index locations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> testGreeting2[0];\n"H"\n> testGreeting2[5];\n"!"\n')),(0,a.kt)("p",null,"Objects that are set up with numbers as their property keys to represent an index location are called ",(0,a.kt)("strong",{parentName:"p"},"array-like objects"),'. We first encountered array-like objects in the "Arrays and Looping" course section when we worked with the Web API objects ',(0,a.kt)("inlineCode",{parentName:"p"},"NodeList")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLCollection"),", which are both objects that contain a collection HTML element objects. These objects are returned from calling methods like ",(0,a.kt)("inlineCode",{parentName:"p"},"document.querySelectorAll()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"document.getElementsByClassName()"),"."),(0,a.kt)("p",null,"There's a couple things to note here. First, take note that while the property keys look like numbers, they are actually strings. This is another situation when JavaScript is not intuitive. Just remember that object keys in JavaScript are always strings. "),(0,a.kt)("p",null,"Also note that not every constructor function returns an array-like object! Only some do. If you encounter an object that has (what seems like) numbers as property keys that start at 0 and increment by one, then you are working with an array-like object."),(0,a.kt)("h3",{id:"object-types-versus-object-instances"},"Object Types versus Object Instances"),(0,a.kt)("p",null,"Let's review the difference between object types and object instances. This will help us when we begin creating our own custom object types."),(0,a.kt)("p",null,"When we've talked about the variable ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," we've described it as an object of a specific type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> let testGreeting2 = new String("Hello!");\n')),(0,a.kt)("p",null,"We've also talked about how the constructor function ",(0,a.kt)("inlineCode",{parentName:"p"},"String()")," creates objects based on a blueprint or template for an object type. Well, the technical terminology to describe these is as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Object type")," or just ",(0,a.kt)("strong",{parentName:"li"},"type"),": The ",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Glossary/Type"},"type")," of an object defines what data it contains, including all of the properties and methods that an object of that type has in it. In other words, the object type is the blueprint or template for creating an object, but not an actual object. With the examples we've seen so far, ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," is a type, and ",(0,a.kt)("inlineCode",{parentName:"li"},"String()")," is the constructor function for that type, whereas ",(0,a.kt)("inlineCode",{parentName:"li"},"testGreeting2")," is an actual ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," object. Notice that the constructor function and the type have the same name! This is by convention.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Note that you'll also see the terminology ",(0,a.kt)("strong",{parentName:"li"},"class")," if you are exploring constructor functions on MDN. A class is simply an object type, and in JavaScript we can create an object type by using class syntax. In a later course section, we'll learn how to use class syntax. "))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Object instance"),": An ",(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Glossary/Instance"},"instance"),' or "object instance" is an actual object of the same type as the constructor that made it. In our recent example ',(0,a.kt)("inlineCode",{parentName:"li"},"testGreeting2")," is an instance of the ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," type. Object instances have the properties and methods that are described in their corresponding type. For example, this means that ",(0,a.kt)("inlineCode",{parentName:"li"},"testGreeting2")," has the string methods like ",(0,a.kt)("inlineCode",{parentName:"li"},"String.prototype.concat()")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"String.prototype.toUpperCase()"),".")),(0,a.kt)("h3",{id:"important-takeaways-so-far"},"Important Takeaways So Far"),(0,a.kt)("p",null,"Whew! We just covered a lot of new information, some of which is more important than others. So, let's refocus on the important takeaways about constructors:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"JavaScript uses constructor functions to make an object of a specific type:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The object type lists all of the properties and methods that every object instance has; it is like a blueprint or template that we can create instances of objects from."),(0,a.kt)("li",{parentName:"ul"},"An object that's created from a constructor function is called an instance, or object instance."),(0,a.kt)("li",{parentName:"ul"},"The first letter of JavaScript constructor functions are capitalized. The naming for constructor functions follows UpperCamelCase."),(0,a.kt)("li",{parentName:"ul"},"The name of the constructor function always matches the name of the object type."))),(0,a.kt)("li",{parentName:"ul"},"Almost every built-in JavaScript object has a constructor function. While it's not common to use constructor functions to create primitives, we can do that, just like with saw with strings."),(0,a.kt)("li",{parentName:"ul"},"The properties and methods that we can access through a string object created with a constructor function are the same properties and methods that we can access in a string primitive. This reminds us that JavaScript turns all primitives into objects, except for ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"undefined"),".")),(0,a.kt)("p",null,"If you are feeling unsure about some of the topics or concepts that we've covered, don't worry \u2014 we'll revisit all of this information as we continue in this course section and we'll have a lot of chance to practice."),(0,a.kt)("p",null,"Next, let's create a custom object type and constructor of our own, and solidify these concepts."),(0,a.kt)("h3",{id:"creating-a-custom-constructor-function-and-object-type"},"Creating a Custom Constructor Function and Object Type"),(0,a.kt)("p",null,"Let's turn back to our original scenario of using constructors to streamline the process of tracking dogs for a dog walker. We'll need to track multiple dogs, and for each dog we'll be tracking the same properties: name, colors, and age. The only difference from dog to dog will be in the values for those properties. Because of this, we can use a blueprint to base every dog off of. Rather than repeating all of the code for each dog in separate object literals, we'll make a constructor function that we can use over and over again."),(0,a.kt)("p",null,"Below is the constructor function for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object type. Here, we're using the constructor function to define what properties the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object type should have in it. We can see in the following example that every dog object we create will have ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"colors"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"age")," properties. Let's put this code into the DevTools console:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"> function Dog(dogName, dogColors, dogAge) {\n  this.name = dogName;\n  this.colors = dogColors;\n  this.age = dogAge;\n}\n")),(0,a.kt)("p",null,"When we call the constructor function ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog()"),", it will create a new instance of the dog object based on the arguments that we pass in:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let myPuppy = new Dog("Ernie", ["brown", "black"], 3);\n> myPuppy;\nDog\xa0{name: \'Ernie\', colors: Array(2), age: 3}\n')),(0,a.kt)("p",null,"We must pass in an argument for every parameter in the constructor function, otherwise, we'll end up with ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," values in our dog object."),(0,a.kt)("p",null,"We can access the name of the new dog:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> myPuppy.name;\n"Ernie"\n')),(0,a.kt)("p",null,"The colors of the new dog:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> myPuppy.colors;\n["brown","black"]\n')),(0,a.kt)("p",null,"And its age:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"> myPuppy.age;\n3\n")),(0,a.kt)("p",null,"Remember, the ",(0,a.kt)("inlineCode",{parentName:"p"},"myPuppy")," object here is an ",(0,a.kt)("strong",{parentName:"p"},"instance")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object ",(0,a.kt)("strong",{parentName:"p"},"type"),"."),(0,a.kt)("p",null,"A constructor is the blueprint that specifies how to create an object of a specific type. You can think of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," constructor here as a factory that can be used repeatedly to build a bunch of dog objects, using the constructor as a blueprint. "),(0,a.kt)("p",null,"This means that we'll always have one ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object type that is defined by a constructor, with potentially many instances of that type. Let's create 3 more dogs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'// instances of the Dog object type\n> let falcor = new Dog("Falcor", ["black"], 4);\n> let nola = new Dog("Nola", ["white", "black"], 6);\n> let patsy = new Dog("Patsy", ["brown"], 7);\n')),(0,a.kt)("p",null,"And each of these ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object instances all have a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," property, a ",(0,a.kt)("inlineCode",{parentName:"p"},"colors")," property and an ",(0,a.kt)("inlineCode",{parentName:"p"},"age")," property. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> falcor.name;\n"Falcor"\n> nola.name;\n"Nola"\n> nola.age;\n6\n> patsy.colors;\n["brown"]\n> patsy.age;\n7\n')),(0,a.kt)("p",null,"Now, we know how to create custom objects with properties, but what about methods? Let's take a look at how to add methods for both JavaScript's ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," type and our custom ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," type next."),(0,a.kt)("h2",{id:"prototypes"},"Prototypes"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"To share functionality between objects, JavaScript uses ",(0,a.kt)("strong",{parentName:"p"},"prototypes"),". A prototype is an object that contains the functionality of a specific object type that is added as a property to the object we're working with. Let's look at an example to make this new information concrete. Do you remember the ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," property on the string object we created? "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let testGreeting2 = new String("Hello!");\nundefined\n> testGreeting2;\nString { Hello! }\n  0: "H", \n  1: "e", \n  2: "l", \n  3: "l", \n  4: "o", \n  5: "!", \n  length: 6, \n  [[Prototype]]: String, \n  [[PrimitiveValue]]: "Hello!"\n')),(0,a.kt)("p",null,"Well, ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," is the property that stores the prototype object for ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2"),". If we want to access the ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," property, we need to do it via ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> testGreeting2.__proto__;\nString\xa0{'', constructor: \u0192, anchor: \u0192, big: \u0192, blink: \u0192,\xa0\u2026}\n")),(0,a.kt)("p",null,"So what does this tell us? ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," is an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object type, and because of this, ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," inherits functionality from the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object type. This inherited functionality is stored in the ",(0,a.kt)("inlineCode",{parentName:"p"},"[[Prototype]]")," property, which we access through ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__"),". In practical terms, this means that any of the string methods we use on ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," are actually inherited from its prototype, the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object type. "),(0,a.kt)("p",null,"This means that any string methods that we call on ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," are actually defined in the prototype object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> testGreeting2.toUpperCase();\n"HELLO!"\n> testGreeting2.charAt(2);\n"l"\n> testGreeting2.includes("ll");\ntrue\n')),(0,a.kt)("p",null,"When we call any of these methods, what happens is JavaScript first looks in the instance object (",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2"),") to find those methods, and if it can't find them there, JavaScript then looks to the ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property to find them in the prototype object. "),(0,a.kt)("p",null,"So, all instances that we create with the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," constructor inherit from the ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype")," object. In fact, every object we create inherits functionality from a prototype object. (We'll see more examples soon!)"),(0,a.kt)("p",null,"Note that we can explore this prototypal inheritance in the DevTools as well. In the following image, the blue square highlights the properties that belong to ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," (the string instance) and the green square highlights the properties that ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2")," inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object type."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/string-instance-inheriting-from-prototype.png",alt:"This image highlights the properties that belong to the `testGreeting2` instance, and which properties it inherits from the `String` object."})),(0,a.kt)("p",null,"Prototypal inheritance is what allows every string we create (with or without the constructor function) to have access to the same set of methods. Note that ",(0,a.kt)("em",{parentName:"p"},"we")," can also add to the prototype object!"),(0,a.kt)("p",null,"Let's add a custom method to ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> String.prototype.addExcitement = function() { return this + "!!!!!!!!!" };\n\u0192 () { return this + "!!!!!!!!!" }\n> testGreeting2.addExcitement();\n"Hello!!!!!!!!!!"\n')),(0,a.kt)("p",null,'As soon as the new method is added, all current and future strings (or more technically, "instances of the ',(0,a.kt)("inlineCode",{parentName:"p"},"String"),' type") will have access to it. Now I can run ',(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2.addExcitement()")," and get ",(0,a.kt)("inlineCode",{parentName:"p"},"Hello!!!!!!!!!"),"."),(0,a.kt)("p",null,"If I create a new string, it, too, will have access to the prototype's ",(0,a.kt)("inlineCode",{parentName:"p"},"addExcitement")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let newGreeting = "Hola";\nundefined\n> newGreeting.addExcitement();\n"Hola!!!!!!!!!"\n')),(0,a.kt)("p",null,"We might think, why aren't methods just added to the constructor instead of to a prototype object that all object instances inherit? Well, the prototype object allows us to define functionality like a method once, and then all instances of that object type automatically have access to it."),(0,a.kt)("p",null,"On the other hand, if we added all string methods to the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," constructor, then every new string we create would have a new instance of every method. For example, if we created three strings, we'd have 3 copies in memory of the ",(0,a.kt)("inlineCode",{parentName:"p"},"toUpperCase()")," method. By adding ",(0,a.kt)("inlineCode",{parentName:"p"},"toUpperCase()")," to the prototype object with ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype.toUpperCase()"),", this method is created only once in memory and shared by all of the string instances, and this is more efficient."),(0,a.kt)("p",null,"Also, while we can directly modify JavaScript object types (such as by adding methods to ",(0,a.kt)("inlineCode",{parentName:"p"},"String.prototype"),"), generally it's a bad practice. We should always add methods to our own custom object types \u2014 otherwise, built-in JavaScript object types in our applications will have unexpected functionality that could be hard for other developers to navigate and debug."),(0,a.kt)("h3",{id:"adding-methods-to-the-dog-prototype"},"Adding Methods to the ",(0,a.kt)("inlineCode",{parentName:"h3"},"Dog")," Prototype"),(0,a.kt)("p",null,"Let's look at our ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," type again. We can add our original methods to ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog.prototype")," so that all dogs have these behaviors available to them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> Dog.prototype.speak = function() {\n  console.log("Woof!");\n};\n\u0192 () {\n  console.log("Woof!");\n}\n> Dog.prototype.humanYears = function() {\n  return this.age * 7;\n};\n\u0192 () {\n  return this.age * 7;\n}\n')),(0,a.kt)("p",null,"Note the semicolons here, by the way. Why are we adding semicolons when we are defining functions? Well, we are using assignment to assign a function to a property. It's somewhat similar to when we assign a value to a variable, so we use semicolons."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"myPuppy")," can now speak:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"> myPuppy.speak();\nWoof!\n")),(0,a.kt)("p",null,"We can also have its age calculated in human years:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"> myPuppy.humanYears();\n21\n")),(0,a.kt)("p",null,"And, every new dog will also have these methods:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'> let newPuppy = new Dog("Goliath", ["gray"], 2);\nundefined\n> newPuppy.speak();\nWoof!\n> newPuppy.humanYears();\n14\n')),(0,a.kt)("p",null,"Just like we did with the string ",(0,a.kt)("inlineCode",{parentName:"p"},"testGreeting2"),", we can view the properties of ",(0,a.kt)("inlineCode",{parentName:"p"},"myPuppy")," in the DevTools console, and see which ones are inherited through the prototype object and which belong to the instance:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/dog-instance-inheriting-from-dog-type.png",alt:"This image highlights which properties belong to the instance `myPuppy` and which are inherited from the `Dog` object type."})),(0,a.kt)("p",null,"We can also access the prototype object through the ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/myPuppy-proto-property.png",alt:"This image shows the prototype that `myPuppy` inherits from the `Dog` object type, which includes the `Dog()` constructor and the two methods `Dog.prototype.speak()` and `Dog.prototype.humanYears()`."})),(0,a.kt)("p",null,"In summary, every time we create a new dog using the ",(0,a.kt)("inlineCode",{parentName:"p"},"new")," keyword, it calls the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog()")," constructor, which provides the blueprint for creating an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," type, giving it certain properties. The new instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," type also automatically gains access to all methods defined on the shared ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," prototype. "),(0,a.kt)("p",null,"Also, we choose to add methods to the prototype of an object type so that we can define the method once, which saves memory and is more efficient."),(0,a.kt)("h3",{id:"prototype-chain"},"Prototype Chain"),(0,a.kt)("p",null,"In JavaScript, all objects inherit functionality from at least one other object, which ultimately derives its functionality from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type. How does this work? Every object has a prototype property (accessed through ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__"),") that is a link to another object. This creates a ",(0,a.kt)("strong",{parentName:"p"},"prototype chain")," and is the mechanism by which one object inherits from multiple other object types. Let's work through some examples of this. "),(0,a.kt)("p",null,"Before we jump in, let's review what the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type is. Do you remember that JavaScript data types are divided into two categories, primitives and objects? Well ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"Object")," type")," corresponds to objects, a foundational data type in JavaScript. We can create an object with literal notation or with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object()")," constructor function. In the following example, we're creating two empty objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"> const myObj = {};\n{}\n> const myOtherObj = new Object();\n{}\n")),(0,a.kt)("p",null,"Being familiar with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type is important, because all JavaScript objects of any and every type inherit functionality from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type is the most generalized object, and all other object types are more specific variations. With that in mind, let's get into examples of the prototype chain!"),(0,a.kt)("p",null,"In this first example, we'll see that an object literal gets its functionality from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/object-prototype.png",alt:"This images shows the results from creating an object literal with `const obj = {}`. We then call `obj.__proto__` and we're able to see that `obj` inherits functionality from the `Object` type."})),(0,a.kt)("p",null,"Note, too, that we can confirm the name of the constructor for our object ",(0,a.kt)("inlineCode",{parentName:"p"},"obj")," by entering the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'> obj.__proto__.constructor.name;\n"Object"\n')),(0,a.kt)("p",null,"And remember that the name of a constructor matches the name of the object type. This confirms that ",(0,a.kt)("inlineCode",{parentName:"p"},"obj")," inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type."),(0,a.kt)("p",null,"If an object inherits functionality from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," type, what does ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," inherit its functionality from? We can move up the chain of prototypes by simply accessing the next ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property: ",(0,a.kt)("inlineCode",{parentName:"p"},"obj.__proto__.__proto__;"),". Let's try entering that into the console:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/null-is-the-end-of-the-prototype-chain.png",alt:"This image shows the result of calling `obj.__proto__.__proto__;` which returns `null`, which designates that we've reached the end of the chain of inheritance."})),(0,a.kt)("p",null,"Notably, we get ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," returned to us. So, what does this mean? Well, when we get ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," returned from accessing a ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property, it means we've reached the end of the chain of inheritance. "),(0,a.kt)("p",null,"Let's see another example with a string. As we'll see, an instance of a string inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," object type, which itself inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," object type. In the following example, we'll use a string literal."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/string-chain-of-inheritance.png",alt:'This image shows the result of doing the following: (1) creating a string with `const myCat = "Kitty Poppins;"`, (2) chaining and accessing `__proto__` properties, first with `myCat.__proto__`, then with `myCat.__proto__.__proto__`, and finally with `myCat.__proto__.__proto__.__proto__`. This shows how `myCat` inherits from `String`, which inherits from `Object`.'})),(0,a.kt)("p",null,"There's a couple things to note in the above code snippet:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We access the ",(0,a.kt)("inlineCode",{parentName:"li"},"__proto__")," property 3 times: once for ",(0,a.kt)("inlineCode",{parentName:"li"},"myCat"),", once for ",(0,a.kt)("inlineCode",{parentName:"li"},"String"),", and once for ",(0,a.kt)("inlineCode",{parentName:"li"},"Object"),". The ",(0,a.kt)("inlineCode",{parentName:"li"},"__proto__")," property for ",(0,a.kt)("inlineCode",{parentName:"li"},"Object")," always returns ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),", which indicates that we've hit the end of the chain of inheritance."),(0,a.kt)("li",{parentName:"ul"},"It's easy to tell that ",(0,a.kt)("inlineCode",{parentName:"li"},"myCat")," inherits from ",(0,a.kt)("inlineCode",{parentName:"li"},"String"),", but harder to tell that ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," inherits from ",(0,a.kt)("inlineCode",{parentName:"li"},"Object"),". To doubly confirm, we inputted ",(0,a.kt)("inlineCode",{parentName:"li"},"myCat.__proto__.__proto__.constructor.name;")," which tells us the name of the constructor for that object type, which is ",(0,a.kt)("inlineCode",{parentName:"li"},'"Object"'),", and this confirms that ",(0,a.kt)("inlineCode",{parentName:"li"},"String")," inherits from ",(0,a.kt)("inlineCode",{parentName:"li"},"Object"),". This confirmation process works, because the name of a constructor function always matches the name of the object type.")),(0,a.kt)("p",null,"Now let's try this same process of accessing the chain of inheritance for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object. Similar to the example with the string, we'll see that an instance of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," type (",(0,a.kt)("inlineCode",{parentName:"p"},"myPuppy"),") inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dog")," object type, which itself inherits from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Object")," object type, which itself does not inherit from anything and ends the chain of inheritance. "),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/OOP-JS/dog-chain-of-inheritance.png",alt:'This image shows the result of doing the following: (1) creating a dog object with `let myPuppy = new Dog("Ernie", ["brown", "black"], 3);`, (2) chaining and accessing `__proto__` properties, first with `myPuppy.__proto__`, then with `myPuppy.__proto__.__proto__`, and finally with `myPuppy.__proto__.__proto__.__proto__`. This shows how `myPuppy` inherits from `Dog`, which inherits from `Object`.'})),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"We've covered a lot of new information in this lesson, and some of it has involved looking under the hood of JavaScript, which isn't always easy. If you are feeling overwhelmed, that's a normal reaction. Don't worry \u2014 we'll get a chance to practice a lot with constructors and prototypes in this section, and we'll continue using these in future sections as well."),(0,a.kt)("p",null,"Here's a summary of the important concepts we covered in this lesson:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"JavaScript objects inherit functionality from other objects through prototypal inheritance."),(0,a.kt)("li",{parentName:"ul"},"A prototype is just an object that lists properties that another object inherits. "),(0,a.kt)("li",{parentName:"ul"},"There's a chain of inheritance by which an instance of an object, like a string or a dog object or a number, inherits from multiple other objects. We can view this inheritance chain by accessing the ",(0,a.kt)("inlineCode",{parentName:"li"},"__proto__")," properties. We know we've reached the end of the prototype chain when we get ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," returned to us."),(0,a.kt)("li",{parentName:"ul"},"We choose to add methods to the prototype of an object type so that we can define the method once, but all object instances still have access to that method. This saves memory and is therefore more efficient. This is in contrast to adding a method to the constructor. In this case, when an instance of an object is created so is a new instance of that method (and any other properties), which takes up more memory."),(0,a.kt)("li",{parentName:"ul"},"Using a constructor function or literal notation creates an instance of an object type based on two things: the properties that are defined in the constructor function and what's added to the prototype object for that object type."),(0,a.kt)("li",{parentName:"ul"},"The name of a constructor function always matches the name of an object type. "),(0,a.kt)("li",{parentName:"ul"},"An instance of an object is stored in a variable and is an actual object, while the object type is the blueprint that defines all of the properties an object of that type should have.")),(0,a.kt)("p",null,"Generally speaking we won't be accessing the ",(0,a.kt)("inlineCode",{parentName:"p"},"__proto__")," property a lot when we're writing our code. However it is really helpful to understand how to access the prototype object in order to actually see how JavaScript's prototypal inheritance works!"),(0,a.kt)("h3",{id:"more-resources"},"More Resources"),(0,a.kt)("p",null,"Note that we've just covered the basics of prototypal inheritance. As always, there's more to learn! Further exploration is optional, but if you are interested in learning more, we recommend these resources:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes"},"Object Prototypes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain"},"Inheritance and the Prototype Chain")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"},"The ",(0,a.kt)("inlineCode",{parentName:"a"},"new")," Operator"))))}u.isMDXComponent=!0}}]);