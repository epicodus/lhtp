"use strict";(self.webpackChunklhtp=self.webpackChunklhtp||[]).push([[2328],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||c[h]||o;return n?i.createElement(m,r(r({ref:t},u),{},{components:n})):i.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},70711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(7896),a=(n(2784),n(30876));const o={title:"Adding Authorization and Associating Users with Items",id:"adding-authorization-and-associating-users-with-items",slug:"adding-authorization-and-associating-users-with-items",hide_table_of_contents:!0,sidebar_position:9,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/c-sharp-full-stack/blob/main/2h_authorization.md"},r=void 0,s={unversionedId:"c-and-net/authentication-with-identity/adding-authorization-and-associating-users-with-items",id:"c-and-net/authentication-with-identity/adding-authorization-and-associating-users-with-items",title:"Adding Authorization and Associating Users with Items",description:"We now have a working user login and registration system, but it doesn't actually have any kind of impact on our application. Our users can do all CRUD regardless of whether they are signed in or not. We'll make our authentication more impactful by limiting what a user can do with authorization.",source:"@site/docs/c-and-net/14_authentication-with-identity/2h-authorization.md",sourceDirName:"c-and-net/14_authentication-with-identity",slug:"/c-and-net/authentication-with-identity/adding-authorization-and-associating-users-with-items",permalink:"/c-and-net/authentication-with-identity/adding-authorization-and-associating-users-with-items",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Adding Authorization and Associating Users with Items",id:"adding-authorization-and-associating-users-with-items",slug:"adding-authorization-and-associating-users-with-items",hide_table_of_contents:!0,sidebar_position:9,day:"weekend",type:"lesson",url:"https://github.com/epicodus-curriculum/c-sharp-full-stack/blob/main/2h_authorization.md"},sidebar:"c-and-net",previous:{title:"Authentication with Identity: User Login and Logout",permalink:"/c-and-net/authentication-with-identity/authentication-with-identity-user-login-and-logout"},next:{title:"Journal #12",permalink:"/c-and-net/authentication-with-identity/journal-12"}},l={},d=[{value:"Authorization",id:"authorization",level:2},{value:"How We&#39;ll Implement Authorization",id:"how-well-implement-authorization",level:3},{value:"Adding Authorization",id:"adding-authorization",level:3},{value:"Other Authorization",id:"other-authorization",level:3},{value:"Associating Users with Items",id:"associating-users-with-items",level:2},{value:"Updating the <code>Item</code> Model",id:"updating-the-item-model",level:3},{value:"Updating the <code>ItemsController</code>",id:"updating-the-itemscontroller",level:3},{value:"Updating the <code>Index()</code> Action",id:"updating-the-index-action",level:3},{value:"Updating <code>Create()</code> POST Action",id:"updating-create-post-action",level:3},{value:"Updating the <code>Item</code> Views for Authorization",id:"updating-the-item-views-for-authorization",level:3},{value:"Adjusting Our Splash Page",id:"adjusting-our-splash-page",level:3},{value:"Next Steps",id:"next-steps",level:2},{value:"Repository Reference",id:"repository-reference",level:3}],u={toc:d},p="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We now have a working user login and registration system, but it doesn't actually have any kind of impact on our application. Our users can do all CRUD regardless of whether they are signed in or not. We'll make our authentication more impactful by limiting what a user can do with authorization."),(0,a.kt)("h2",{id:"authorization"},"Authorization"),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Authorization")," is the process of managing what a user is allowed to do. We'll update our To Do List application so that only logged in users will be able to see their own list of items. This is similar to many real-world applications such as email or blog sites where a signed-in user has access to their own content. As we'll see, adding authorization is very simple, but associating items with a user takes more refactoring."),(0,a.kt)("p",null,"Note that we will not modify categories or tags in this lesson and that by the end of this lesson, authorization will only be applied to creating and viewing a user's items. However, we encourage you to practice more with authorization by adding it to categories and tags on your own."),(0,a.kt)("h3",{id:"how-well-implement-authorization"},"How We'll Implement Authorization"),(0,a.kt)("p",null,"To implement authorization, we'll be using tools from ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization?view=aspnetcore-6.0"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"Microsoft.AspNetCore.Authorization")," namespace"),". These authorization tools work in conjunction with Identity, which provides authentication."),(0,a.kt)("p",null,"We'll specifically implement ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-6.0"},"simple authorization"),", though the MS Docs have guidance on other ways to authorize users. ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0"},"Check out the docs on authorization")," for more information!"),(0,a.kt)("h3",{id:"adding-authorization"},"Adding Authorization"),(0,a.kt)("p",null,"To add authorization to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),", we'll use the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute along with a ",(0,a.kt)("inlineCode",{parentName:"p"},"using")," statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace ToDoList.Controllers\n{\n  [Authorize] // New line\n  public class ItemsController : Controller\n  {\n    ...\n  }\n}\n")),(0,a.kt)("p",null,"We add a using directive for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Microsoft.AspNetCore.Authorization")," namespace so that we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute."),(0,a.kt)("p",null,"Notice that we include an ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute on ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\n[Authorize]\npublic class ItemsController : Controller\n...\n")),(0,a.kt)("p",null,"This allows access to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController")," only if a user is logged in. We'll add this attribute to a controller whenever we want to limit its access to signed-in users only."),(0,a.kt)("p",null,"And with this simple addition, we've added authorization to our application!"),(0,a.kt)("h3",{id:"other-authorization"},"Other Authorization"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Adding ",(0,a.kt)("inlineCode",{parentName:"strong"},"[Authorize]")," to a controller is just one application of authorization.")," We can also add the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute to individual controller actions. "),(0,a.kt)("p",null,"When we add ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),", the entirety of the controller is shielded from unauthorized users. We can negate this by including an ",(0,a.kt)("inlineCode",{parentName:"p"},"[AllowAnonymous]")," attribute above any specific methods that we want unauthorized users to have access to. For example, we could put ",(0,a.kt)("inlineCode",{parentName:"p"},"[AllowAnonymous]")," above the ",(0,a.kt)("inlineCode",{parentName:"p"},"Index")," route, if we want users to be able to see a list of items, but require authorization before they view details. "),(0,a.kt)("p",null,"Alternatively, we could avoid putting the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute on the entire class, and instead only place it on specific methods we want guarded. For example, if we wanted unauthorized users to view many routes in a controller, but protect your ",(0,a.kt)("inlineCode",{parentName:"p"},"Create"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Update"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"Delete")," routes, you could simply ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," those specific methods."),(0,a.kt)("p",null,"For the purposes of learning basic authorization tools, we'll continue with the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," route on the entire controller, as shown. As noted earlier, we're implementing ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-6.0"},"simple authorization"),". To learn about other ways to add authorization to our ASP.NET Core, visit the ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0"},"docs on authorization"),"."),(0,a.kt)("h2",{id:"associating-users-with-items"},"Associating Users with Items"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"With authorization now added to our ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),", you need to be signed in to visit any route for items. However once we are signed in, we can see any user's items. To make our authorization more meaningful, we'll update our To Do List app so that each item that is created is associated with the logged in user, and the only items visible to a user is their own."),(0,a.kt)("h3",{id:"updating-the-item-model"},"Updating the ",(0,a.kt)("inlineCode",{parentName:"h3"},"Item")," Model"),(0,a.kt)("p",null,"To achieve our goal, the first thing we'll do is create an association between Identity's ",(0,a.kt)("inlineCode",{parentName:"p"},"ApplicationUser")," and our ",(0,a.kt)("inlineCode",{parentName:"p"},"Item")," class. This will enable us to associate items with a specific user, and fetch and display only the items that belong to that user."),(0,a.kt)("p",null,"Let's add a new ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," property to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Item.cs")," model, which should then look like this:"),(0,a.kt)("div",{class:"filename"},"Models/Item.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'using System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace ToDoList.Models\n{\n  public class Item\n  {\n    public int ItemId { get; set; }\n    [Required(ErrorMessage = "The item\'s description can\'t be empty!")]\n    public string Description { get; set; }\n    [Range(1, int.MaxValue, ErrorMessage = "You must add your item to a category. Have you created a category yet?")]\n    public int CategoryId { get; set; }\n    public Category Category { get; set; }\n    public List<ItemTag> JoinEntities { get;}\n    public ApplicationUser User { get; set; }  // New line!\n  }\n}\n')),(0,a.kt)("p",null,"Since we've updated our entity model, we need to create a new migration and update the database. In our ",(0,a.kt)("inlineCode",{parentName:"p"},"ToDolist/")," directory, let's run the following command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ dotnet ef migrations add AddUserToItem\n")),(0,a.kt)("p",null,"This command will add a new migration and its corresponding designer file to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Migrations/")," directory while updating the model snapshot for our ",(0,a.kt)("inlineCode",{parentName:"p"},"ToDoListContext"),". "),(0,a.kt)("p",null,"Now, let's update the database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"$ dotnet ef database update\n")),(0,a.kt)("h3",{id:"updating-the-itemscontroller"},"Updating the ",(0,a.kt)("inlineCode",{parentName:"h3"},"ItemsController")),(0,a.kt)("p",null,"Next, let's update our ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),". We'll start by adding the following ",(0,a.kt)("inlineCode",{parentName:"p"},"using")," statements:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\n//new code\nusing Microsoft.AspNetCore.Identity;\nusing System.Threading.Tasks;\nusing System.Security.Claims;\n...\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We'll need ",(0,a.kt)("inlineCode",{parentName:"li"},"Microsoft.AspNetCore.Identity")," so our controller can use the ",(0,a.kt)("inlineCode",{parentName:"li"},"UserManager")," and other tools from Identity to get users from the database."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"System.Threading.Tasks")," is necessary to call async methods. The async methods we'll use are from the ",(0,a.kt)("inlineCode",{parentName:"li"},"UserManager")," class."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"System.Security.Claims")," is necessary for using ",(0,a.kt)("strong",{parentName:"li"},"claim based authorization"),". A ",(0,a.kt)("strong",{parentName:"li"},"claim")," is a form of user identification. It states who a user is, not what the user can actually do. While the user identification itself doesn't authorize a user to do anything, it is necessary for us to be able to identify a user (through a claim) in order to get only the items that are associated with that user.")),(0,a.kt)("p",null,"Next, we'll add Identity's ",(0,a.kt)("inlineCode",{parentName:"p"},"UserManager")," class to our controller so that we can access tools to get us data about the signed-in user. We'll add a new property and update our constructor like so:"),(0,a.kt)("div",{class:"filename"},"Controllers/ItemsController.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\nnamespace ToDoList.Controllers\n{\n  [Authorize]\n  public class ItemsController : Controller\n  {\n    private readonly ToDoListContext _db;\n    private readonly UserManager<ApplicationUser> _userManager; // New line\n\n    // Updated constructor\n    public ItemsController(UserManager<ApplicationUser> userManager, ToDoListContext db)\n    {\n      _userManager = userManager;\n      _db = db;\n    }\n...\n")),(0,a.kt)("p",null,"Let's break this code down into smaller pieces."),(0,a.kt)("p",null,"First, let's take a look at our ",(0,a.kt)("inlineCode",{parentName:"p"},"readonly")," property and our constructor:"),(0,a.kt)("div",{class:"filename"},"Controllers/ItemsController.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\nprivate readonly UserManager<ApplicationUser> _userManager;\n\npublic ItemsController(UserManager<ApplicationUser> userManager, ToDoListContext database)\n{\n  _userManager = userManager;\n  _db = database;\n}\n...\n")),(0,a.kt)("p",null,"This code should look more familiar because our ",(0,a.kt)("inlineCode",{parentName:"p"},"AccountController")," has the exact same code. We need an instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"UserManager")," in order to access the tools that get us data about the signed-in user. We also include a constructor to instantiate private ",(0,a.kt)("inlineCode",{parentName:"p"},"readonly")," instances of the database and the ",(0,a.kt)("inlineCode",{parentName:"p"},"UserManager"),"."),(0,a.kt)("h3",{id:"updating-the-index-action"},"Updating the ",(0,a.kt)("inlineCode",{parentName:"h3"},"Index()")," Action"),(0,a.kt)("p",null,"Let's update our ",(0,a.kt)("inlineCode",{parentName:"p"},"Index()")," method to determine who the currently signed-in user is, and to grab only their items from the database. Here's what our ",(0,a.kt)("inlineCode",{parentName:"p"},"Index()")," action should now look like:"),(0,a.kt)("div",{class:"filename"},"Controllers/ItemsController.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\n    public async Task<ActionResult> Index()\n    {\n      string userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n      ApplicationUser currentUser = await _userManager.FindByIdAsync(userId);\n      List<Item> userItems = _db.Items\n                          .Where(entry => entry.User.Id == currentUser.Id)\n                          .Include(item => item.Category)\n                          .ToList();\n      return View(userItems);\n    }\n...\n")),(0,a.kt)("p",null,"There's a lot to unpack here."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We start by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," modifier because this action will run asynchronously. Because the action is asynchronous, it also returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"Task")," containing an action result.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Then we locate the unique identifier for the currently-logged-in user and assign it the variable name ",(0,a.kt)("inlineCode",{parentName:"p"},"userId"),". Let's go over the new logic in the following line of code:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"string userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.user?view=aspnetcore-6.0"},(0,a.kt)("inlineCode",{parentName:"a"},"User"))," is a property of our ",(0,a.kt)("inlineCode",{parentName:"li"},"ItemsController")," (which extends from ",(0,a.kt)("inlineCode",{parentName:"li"},"Controller"),"), just like ",(0,a.kt)("inlineCode",{parentName:"li"},"ModelState")," is, and we can call on this property anywhere within our controller. ",(0,a.kt)("inlineCode",{parentName:"li"},"User")," contains information about the currently signed-in user."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.security.claims.claimsprincipal.findfirst?view=net-6.0"},(0,a.kt)("inlineCode",{parentName:"a"},"FindFirst()"))," is a method that locates the first user record that meets the provided criteria."),(0,a.kt)("li",{parentName:"ul"},"This method takes ",(0,a.kt)("inlineCode",{parentName:"li"},"ClaimTypes.NameIdentifier")," as an argument. This is why we need a ",(0,a.kt)("inlineCode",{parentName:"li"},"using")," directive for ",(0,a.kt)("inlineCode",{parentName:"li"},"System.Security.Claims"),". We specify ",(0,a.kt)("inlineCode",{parentName:"li"},"ClaimTypes.NameIdentifier")," to locate the unique ID associated with the currently signed in user account. ",(0,a.kt)("inlineCode",{parentName:"li"},"NameIdentifier")," is a property that refers to an Entity's unique ID. See ",(0,a.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/dotnet/api/system.security.claims.claimtypes?view=net-6.0"},"the ClaimTypes documentation")," for more information on this class."),(0,a.kt)("li",{parentName:"ul"},"Finally, we include the ",(0,a.kt)("inlineCode",{parentName:"li"},"?")," operator after the line ",(0,a.kt)("inlineCode",{parentName:"li"},"this.User.FindFirst(ClaimTypes.NameIdentifier)"),". This is called an ",(0,a.kt)("strong",{parentName:"li"},"existential operator"),". It states that we should only call the property to the right of the ",(0,a.kt)("inlineCode",{parentName:"li"},"?")," if the method to the left of the ",(0,a.kt)("inlineCode",{parentName:"li"},"?")," doesn't return ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),". ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Essentially, the code states that if ",(0,a.kt)("inlineCode",{parentName:"li"},"this.User.FindFirst(ClaimTypes.NameIdentifier)")," returns ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),", don't call the property to the right of the existential operator. However, if it doesn't return ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),", it retrieves ",(0,a.kt)("inlineCode",{parentName:"li"},"Value")," property."),(0,a.kt)("li",{parentName:"ul"},"In other words, if we successfully locate the ",(0,a.kt)("inlineCode",{parentName:"li"},"NameIdentifier")," of the current user, we'll call ",(0,a.kt)("inlineCode",{parentName:"li"},"Value")," to retrieve the actual unique identifier value.")))),(0,a.kt)("p",null,"Once we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"userId")," value, we're ready to call our async method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"ApplicationUser currentUser = await _userManager.FindByIdAsync(userId);\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"First we call Identity's ",(0,a.kt)("inlineCode",{parentName:"li"},"UserManager")," service that we've injected into this controller."),(0,a.kt)("li",{parentName:"ul"},"We call the ",(0,a.kt)("inlineCode",{parentName:"li"},"FindByIdAsync()")," method, which, as its name suggests, is a built-in Identity method used to find a user's account by their unique ID."),(0,a.kt)("li",{parentName:"ul"},"We provide the ",(0,a.kt)("inlineCode",{parentName:"li"},"userId")," we just located as an argument to ",(0,a.kt)("inlineCode",{parentName:"li"},"FindByIdAsync()"),"."),(0,a.kt)("li",{parentName:"ul"},"Thanks to the handy ",(0,a.kt)("inlineCode",{parentName:"li"},"Async")," suffix in this method's name, we know it runs asynchronously. We include the ",(0,a.kt)("inlineCode",{parentName:"li"},"await")," keyword so the code will wait for Identity to locate the correct user before moving on.")),(0,a.kt)("p",null,"Finally, we create a variable to store a collection containing only the ",(0,a.kt)("inlineCode",{parentName:"p"},"Item"),"s that are associated with the currently-logged-in user's unique ",(0,a.kt)("inlineCode",{parentName:"p"},"Id")," property:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"...\nList<Item> userItems = _db.Items\n                    .Where(entry => entry.User.Id == currentUser.Id)\n                    .Include(item => item.Category)\n                    .ToList();\nreturn View(userItems);\n...\n")),(0,a.kt)("p",null,"We use ",(0,a.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where?view=net-6.0"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"Where()")," method"),", which is a LINQ method we can use to filter a collection in a way that echoes the logic of the ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3schools.com/mysql/mysql_where.asp"},"SQL ",(0,a.kt)("inlineCode",{parentName:"a"},"WHERE")," clause"),". We can use ",(0,a.kt)("inlineCode",{parentName:"p"},"Where()")," to make many different kinds of queries, as the method accepts an expression to filter our results."),(0,a.kt)("p",null,"In this case, we're simply asking EF Core to find items in the database where the user id associated with the item is the same id as the id that belongs to the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentUser"),". This ensures the signed-in user only sees their own items in the view."),(0,a.kt)("h3",{id:"updating-create-post-action"},"Updating ",(0,a.kt)("inlineCode",{parentName:"h3"},"Create()")," POST Action"),(0,a.kt)("p",null,"Let's now edit our ",(0,a.kt)("inlineCode",{parentName:"p"},"Create()")," POST action. Make sure you update the ",(0,a.kt)("strong",{parentName:"p"},"post")," method and not the ",(0,a.kt)("strong",{parentName:"p"},"get")," method."),(0,a.kt)("div",{class:"filename"},"Controllers/ItemsController.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'    [HttpPost]\n    public async Task<ActionResult> Create(Item item, int CategoryId)\n    {\n      if (!ModelState.IsValid)\n      {\n        ViewBag.CategoryId = new SelectList(_db.Categories, "CategoryId", "Name");\n        return View(item);\n      }\n      else\n      {\n        string userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        ApplicationUser currentUser = await _userManager.FindByIdAsync(userId);\n        item.User = currentUser;\n        _db.Items.Add(item);\n        _db.SaveChanges();\n        return RedirectToAction("Index");\n      }\n    }\n')),(0,a.kt)("p",null,"Everything with the model validation is the same. We've only updated the ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," branch of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Create()")," POST method. "),(0,a.kt)("p",null,"The first two lines within the ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," branch are exactly the same as the first two lines of our ",(0,a.kt)("inlineCode",{parentName:"p"},"Index()")," action: we start by finding the value of the current user. "),(0,a.kt)("p",null,"Once we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentUser")," object, we associate it with the ",(0,a.kt)("inlineCode",{parentName:"p"},"Item"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"User")," property. This makes the association so that an ",(0,a.kt)("inlineCode",{parentName:"p"},"Item")," belongs to a ",(0,a.kt)("inlineCode",{parentName:"p"},"User"),". "),(0,a.kt)("p",null,"Finally, we add the item to the database and save it, just as we did before."),(0,a.kt)("h3",{id:"updating-the-item-views-for-authorization"},"Updating the ",(0,a.kt)("inlineCode",{parentName:"h3"},"Item")," Views for Authorization"),(0,a.kt)("p",null,"Well... we actually don't have to update our views at all. All of the associating between items and the logged in user happens in the ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),"."),(0,a.kt)("p",null,"We can, however, make a small update to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Items/Index.cshtml"),". Let's address the signed in user by name. To do this, we'll update our introductory header like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"<h1>Items for @User.Identity.Name</h1>\n")),(0,a.kt)("p",null,"And here's how the entire file will look:"),(0,a.kt)("div",{class:"filename"},"Views/Items/Index.cshtml"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models;\n\n<h1>Items for @User.Identity.Name</h1>\n\n@if (@Model.Count == 0)\n{\n  <h3>No items have been added yet!</h3>\n} \nelse\n{\n  <ul>\n    @foreach (Item item in Model)\n    {\n      <li>@Html.ActionLink($"{item.Description}", "Details", new { id = item.ItemId }) | @item.Category.Name</li>\n    }\n  </ul>\n}\n\n<p>@Html.ActionLink("Add new item", "Create")</p>\n<p>@Html.ActionLink("Home", "Index", "Home")</p>\n')),(0,a.kt)("p",null,"Because we've added the ",(0,a.kt)("inlineCode",{parentName:"p"},"[Authorize]")," attribute to our ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),", we know that only logged in users will be able to view this page, so we can safely update our header to directly address the user's ",(0,a.kt)("inlineCode",{parentName:"p"},"Name"),"."),(0,a.kt)("p",null,"So what happens if an unauthorized user (who is not signed in) tries to access our item's ",(0,a.kt)("inlineCode",{parentName:"p"},"Index.cshtml"),"? Identity will automatically redirect them to the login page, just like in the following image:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://learnhowtoprogram.s3.us-west-2.amazonaws.com/c%23/aspnet_authorization_redirect.png",alt:"Identity redirects unauthorized users to the `Account/Login.cshtml` view."})),(0,a.kt)("h3",{id:"adjusting-our-splash-page"},"Adjusting Our Splash Page"),(0,a.kt)("p",null,"We're almost done with our refactor. The one thing we have not addressed is what to do about our splash page. Right now it lists all items saved in the items database (along with all categories). Now that only logged in users can view their own items, we need to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"HomeController")," to get the logged in user's items, and our view to display a message asking visitors to log in if they want to see their own items."),(0,a.kt)("p",null,"Let's start with the ",(0,a.kt)("inlineCode",{parentName:"p"},"HomeController")," first. Here's the updated controller:"),(0,a.kt)("div",{class:"filename"},"Controllers/HomeController.cs"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'using Microsoft.AspNetCore.Mvc;\nusing ToDoList.Models;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.AspNetCore.Identity;\nusing System.Threading.Tasks;\nusing System.Security.Claims;\n\nnamespace ToDoList.Controllers\n{\n    public class HomeController : Controller\n    {\n      private readonly ToDoListContext _db;\n      private readonly UserManager<ApplicationUser> _userManager;\n\n      public HomeController(UserManager<ApplicationUser> userManager, ToDoListContext db)\n      {\n        _userManager = userManager;\n        _db = db;\n      }\n\n      [HttpGet("/")]\n      public async Task<ActionResult> Index()\n      {\n        Category[] cats = _db.Categories.ToArray();\n        Dictionary<string,object[]> model = new Dictionary<string, object[]>();\n        model.Add("categories", cats);\n        string userId = this.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        ApplicationUser currentUser = await _userManager.FindByIdAsync(userId);\n        if (currentUser != null)\n        {\n          Item[] items = _db.Items\n                      .Where(entry => entry.User.Id == currentUser.Id)\n                      .ToArray();\n          model.Add("items", items);\n        }\n        return View(model);\n      }\n    }\n}\n')),(0,a.kt)("p",null,"First notice that we add new using directives to access the tools we need to get the current user:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"using Microsoft.AspNetCore.Identity;")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"using System.Threading.Tasks;")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"using System.Security.Claims;"))),(0,a.kt)("p",null,"Next, notice that we add Identity's ",(0,a.kt)("inlineCode",{parentName:"p"},"UserManager")," to our controller as a property (",(0,a.kt)("inlineCode",{parentName:"p"},"_userManager"),") and by updating our controller's constructor to access the ",(0,a.kt)("inlineCode",{parentName:"p"},"UserManager")," service through dependency injection. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"    public class HomeController : Controller\n    {\n      ...\n      private readonly UserManager<ApplicationUser> _userManager;\n\n      public HomeController(UserManager<ApplicationUser> userManager, ToDoListContext db)\n      {\n        _userManager = userManager;\n        _db = db;\n      }\n      ...\n    }\n...\n")),(0,a.kt)("p",null,"Next, notice the changes in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Index()")," action. Here is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Index()")," action one more time:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'      [HttpGet("/")]\n      public async Task<ActionResult> Index()\n      {\n        // Category logic\n        Category[] cats = _db.Categories.ToArray();\n        Dictionary<string,object[]> model = new Dictionary<string, object[]>();\n        model.Add("categories", cats);\n        // Item logic\n        string userId = this.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        ApplicationUser currentUser = await _userManager.FindByIdAsync(userId);\n        if (currentUser != null)\n        {\n          Item[] items = _db.Items\n                      .Where(entry => entry.User.Id == currentUser.Id)\n                      .ToArray();\n          model.Add("items", items);\n        }\n        return View(model);\n      }\n')),(0,a.kt)("p",null,"With this update, we've reorganized the existing code, along with adding new code. Now instead of turning the entire items database into an array, we only do so if there's a currently logged in user. Note that this is just one way of many for setting up this logic. You are welcome to reimagine this logic or the data types used as you see fit. Now let's break down this code a bit more."),(0,a.kt)("p",null,"First, we deal with displaying our categories. Here, we also create the dictionary ",(0,a.kt)("inlineCode",{parentName:"p"},"model")," that will hold our category and item data."),(0,a.kt)("p",null,"Then, we go through the process of getting the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentUser")," object. This is the same code that we used earlier in our ",(0,a.kt)("inlineCode",{parentName:"p"},"ItemsController"),". "),(0,a.kt)("p",null,"Next, we create a branch that checks if the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentUser")," is not ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"currentUser")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),", that means there's no signed in user and we simply return the view with no items."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"currentUser")," has a value (is not ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),"), we go through the process of fetching the items belonging to that user and adding them to our view's ",(0,a.kt)("inlineCode",{parentName:"li"},"model"),".")),(0,a.kt)("p",null,"Now let's see how we'll update the view to work with the new model we've created in our controller action. Take note that our ",(0,a.kt)("inlineCode",{parentName:"p"},"Home/Index.cshtml")," view will only have an ",(0,a.kt)("inlineCode",{parentName:"p"},"items")," key in our dictionary ",(0,a.kt)("inlineCode",{parentName:"p"},"model")," if there's a logged in user. That means we need to make sure that our view ensures there's an authenticated user before displaying items. "),(0,a.kt)("p",null,"Here's the updated code for the entire ",(0,a.kt)("inlineCode",{parentName:"p"},"Home/Index.cshtml"),":"),(0,a.kt)("div",{class:"filename"},"Views/Home/Index.cshtml"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'@{\n  Layout = "_Layout";\n}\n\n@using ToDoList.Models;\n\n<h1>Welcome to the To Do List!</h1>\n\n<hr />\n\n<h4>Categories</h4>\n@if (Model["categories"].Length == 0)\n{\n  <p>No categories have been added yet!</p>\n} \n<ul>\n  @foreach (Category cat in Model["categories"])\n  {\n    <li>@Html.ActionLink(@cat.Name, "Details", "Categories", new { id = @cat.CategoryId})</li>\n  }\n</ul>\n\n@if (User.Identity.IsAuthenticated)\n{\n  <h4>Items for @User.Identity.Name</h4>\n  @if (Model["items"].Length == 0)\n  {\n    <p>No items have been added yet!</p>\n  } \n  <ul>\n    @foreach (Item item in Model["items"])\n    {\n      <li>@Html.ActionLink(@item.Description, "Details", "Items", new { id = @item.ItemId})</li>\n    }\n  </ul>\n}\nelse\n{\n  <h4>Items</h4>\n  <p>Please @Html.ActionLink("log in", "LogIn", "Account") to view or manage your items.</p>\n}\n\n<hr />\n\n<p>@Html.ActionLink("Manage items", "Index", "Items")</p> \n<p>@Html.ActionLink("Manage categories", "Index", "Categories")</p>\n<p>@Html.ActionLink("Manage tags", "Index", "Tags")</p>\n<p>@Html.ActionLink("Create or manage an account", "Index", "Account")</p>\n')),(0,a.kt)("p",null,"Here's the code that specifically deals with displaying items:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'@if (User.Identity.IsAuthenticated)\n{\n  <h4>Items for @User.Identity.Name</h4>\n  @if (Model["items"].Length == 0)\n  {\n    <p>No items have been added yet!</p>\n  } \n  <ul>\n    @foreach (Item item in Model["items"])\n    {\n      <li>@Html.ActionLink(@item.Description, "Details", "Items", new { id = @item.ItemId})</li>\n    }\n  </ul>\n}\nelse\n{\n  <h4>Items</h4>\n  <p>Please @Html.ActionLink("log in", "LogIn", "Account") to view or manage your items.</p>\n}\n')),(0,a.kt)("p",null,"In this update, we check ",(0,a.kt)("inlineCode",{parentName:"p"},"User.Identity.IsAuthenticated")," to determine whether there's a user that's signed in. If so, then we display the items as well as the user's name. And if not, then we display a message asking the visitor to sign in to view or manage their items."),(0,a.kt)("h2",{id:"next-steps"},"Next Steps"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Now we're ready to go! Start your application and click around. Try accessing the items pages when you are not signed in to see how Identity redirects you to the log in view. Then try accessing the items pages when you are logged in. Next, try logging into different accounts to see that the items in each list are different.  "),(0,a.kt)("p",null,"Keep in mind that we've only added simple authorization to our To Do List app. While we can associate items with a specific user, and only display a logged in user's items, as long as you are logged in you can still hack your way to accessing other items in the database by directly entering a URL like ",(0,a.kt)("inlineCode",{parentName:"p"},"https://localhost:5001/Items/Details/1"),". That means we have more work to do as far as boosting the security of our details, edit, and delete routes. Using the tools in this lesson, can you think of a way to do this? This task is for your further exploration."),(0,a.kt)("h3",{id:"repository-reference"},"Repository Reference"),(0,a.kt)("p",null,"Follow the link below to view how a sample version of the project should look at this point. Note that this is a link to a specific branch in the repository."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"https://github.com/epicodus-lessons/section-5-to-do-list-with-auth-csharp-net6/tree/3_authorization"},(0,a.kt)("i",{class:"glyphicon glyphicon-folder-open"})," Example GitHub Repo for To Do List with Authentication and Authorization: ",(0,a.kt)("inlineCode",{parentName:"a"},"3_authorization")))))}c.isMDXComponent=!0}}]);